�ndex
Introducci�	3
Introducci�	3
Parlant de codi accessible	3
Com est� organitzat el quadern?	3
Programaci� B�sica	4
El m�s r�pid	5
Pedra, paper, tisora	7
Codi Morse	10
El batec de la Micro:bit	15
Conta enrere	17
Programaci� Interm�dia	19
El foraster m�s r�pid	20
Un contra l�altre	27
Missatge secret	33
Atac de cor a la Micro:bit	36
Programaci� Avan�ada	38
El pistoler m�s r�pid	39
Tria tu	43
Enviant un missatge	46
El cor de la Micro:bit	47
El m�s r�pid	51
Pedra, Paper, Tisora	52
Codi Morse	53
El batec de la Micro:bit	54
Conta enrere	55
El foraster m�s r�pid	56
Un contra l�altre	58
Missatge Secret	61
Atac de cor a la Micro:bit	63
El pistoler m�s r�pid	64
Tria tu	67
Enviant un missatge	71
El cor de la Micro:bit	73



Introducci�
Introducci�
Moltes de les aplicacions que hi ha per fer amb Micro:bit tenen dos greus problemes per usuaris amb discapacitat visual.
1. El codi tendeix a estar en format HEX (blocs).
2. La Micro:bit no sol realitzar cap no emet cap est�mul sonor.
A aquest petit quadern es vol mostrar com realitzar programes accessibles per la Micro:bit i com programar de forma accessible per que tots els usuaris puguin crear les modificacions necess�ries o personalitzar el codi ja creat.
Parlant de codi accessible
Si es vol crear un codi accessible, �s a dir, que tots els usuaris puguin consultar i modificar, a dia d�avui no podem utilitzar la programaci� per blocs. Per tant la p�gina de MakeCode amb els blocs queda descartada.
A banda dels blocs de programaci� es poden utilitzar dos llenguatges de programaci�:
> JavaScript.
> Python.
A aquest manual s�utilitzar� Python per la realitzaci� dels programes. Tots els programes es compartiran a MakeCode, i per tant es podr� veure i descarregar el codi en JavaScript i en- Blocs (en alguns cassos).
Per realitzar la programaci�, en lloc de MakeCode s�utilitzar� l�editor de Python, que permet utilitzar m�s caracter�stiques del llenguatge de programaci�, algunes de les quals no es poden reproduir a la programaci� per blocs.
Aquest editor t� un problema en front de MakeCode i �s que no es pot emmagatzemar a un repositori que s�obri amb la p�gina web. Per tant, tot s�emmagatzemar� a un repositori propi, i tamb� a MakeCode.
Aquest editor �s accessible amb els lectors de pantalla, tot i que presenta alguns problemes en el seu �s.
Com est� organitzat el quadern?
El quadren est� organitzat en tres seccions b�siques:
1. Programaci� B�sica.
2. Programaci� Interm�dia.
3. Programaci� Avan�ada.
Al nivell principiant s�explicar� l�nia a l�nia el que fa el codi, al menys als primers exemples. Aquesta explicaci� ser� menor al nivell interni, on nom�s s�explicaran el per que d�algunes l�nies. A mesura del possible, els projectes Intermedis seran ampliacions del codi d�un projecte que s�ha iniciat a la Programaci� B�sica.
A l�annex del document s�inclou una petita fitxa de cada projecte on hi ha un petit resum sobre les caracter�stiques i les funcions que s�utilitzen pel seu desenvolupament.
Programaci� B�sica


El m�s r�pid
Introducci�
Ets el m�s r�pid a aquesta banda del Llobregat? Anem a veure-ho! Prepara els teus dits per veure qui desenfunda m�s r�pid
Objectiu
Aquest primer projecte amb Python per Micro:bit �s un senzill codi que ens permetr� crear un joc per a dos jugador amb una �Micro:bito:bit. El joc consisteix en veure qui pitja de forma m�s r�pida el boMicro:bitMicro:bit. Un temporitzador valorar� si el jugador A ha pitjar el bot� A abans que el jugador B pitgi el Micro:bit la Micro:bit.
Llestos. A les seves marques. Ja!
Primers passos
Per crear el nostre projecte comen�arem, com sempre, important els m�duls necessaris, que en aquest cas ser� nom�Micro:biticro:bit.
1	from microbit import *
Un cop importat el m�dul comen�arem el bucle de l�aplicaci� amb un bucle while de la seg�ent manera:
5	while True
Els bucles while s�executen sempre que la condici� sigui certa. D�aquest forma, si creem un bucle while True, estem creant un bucle infinit ja que la condici� d�inicialitzaci� del bucle sempre ser� certa.
Un cop creat el bucle que controlar� l�execuci� del projecte, hem de crear dos bucles if. Un pel bot� A i un altre pel bot� B. El bucle pel bot� ser�:
6		if button_a_is.pressed():
7			display.show(Image.ARROW.W)
Segons aquest bucle, quan es pitgi el bot� A apareixer� en pantalla un fletxa indicant que el bot� A ha sigut el primer en ser pitjat.
Pel bot� B farem el mateix bucle modificant que el bot� a pitjat �s el B i el sentit de la fletxa. El bucle ser� de la forma:
9		if button_b_is.pressed():
10			display.show(Image.ARROW.E)
Si executem ara el codi del projecte veurem que apareix una fletxa indicant quin bot� ha sigut el que s�ha pitjat abans, i per tant, al guanyador. Per� aquest codi t� una gran mancan�a ara mateix, i �s que la indicaci� �s nom�s visual. Anem a incorporar una senyal sonora de forma que emeti un so diferent quan es pitja el bot� A o el bot� B.
Incorporant sons
Per incorporar un so primer haurem d�importar un nou m�dul, D�aquesta manera, a sota de l�import del mMicro:biticro:bit escriurem:
3	 import music
Al importar aquest m�dul, ara podrem fer que lMicro:bitit emeto diferents sons. Per que emeti un so al pitjar el bot� A, escriurem, dins del bucle del bot� A la seg�ent l�nia:
9	music.play(�a�)
A dins del bucle pel bot� B escriurem el mateix per� en lloc d�a escriurem b de la seg�ent manera:
13	music.play(�b�)
Ara de forma sonora s�est� indicant qui ha sigut el primer en pitjar un bot�.
El joc ha millorat for�a. Tot i aix� continua havent-hi un petit problema. Quin?
Que un dels jugadors, o els dos jugadors, ha de realitzar una conta enrere per que comenci el joc. Per� podem fer que aix� ho faciMicro:bit:bit per nosaltres, com veurem m�s endavant a El foraster m�s r�pid.
Codi
El codi sencer d�aquest projecte es pot consultar a la secci� El m�s r�pid de l�Ap�ndix.


Pedra, paper, tisora
Introducci�
Qui m�s qui menys al llarg de la seva infantesa ha jugat al joc de pedra, paper, tisora. A aquest projecte volem anar una mica m�s enll� i jugar al joc ambMicro:bitro:bit.
Per realitzar aquest projecte haurem d�utilitzar els m�duls speech i random deMicro:bit:bit. La designaci� del que trauMicro:bitro:bit per pantalla es far� de forma aleat�ria al saMicro:bit Micro:bit.
Se que tens moltes ganes de comen�ar a jugar. Aix� doncs: COMENCEM!
Important els m�duls
Com sempre, el primer que farem ser� importar els m�duls necessaris per la realitzaci� del projecte. Per aquest projecte necessitarem els seg�ents m�duls;
* microbit.
* random.
* speech.
Aix� doncs, el nostre programa en Python ha de comen�ar de la seg�ent manera:
1 # Imports
2 from microbit import *
3 import random
4 import speech
Bucle principal
Un cop tenim els imports declarats, crearem el bucle inicial, que com sempre, a aquesta secci� de Programaci� B�sica �s un del tipus while True. Recordem que aquest �s un bucle infinit i que per tant, sempre s�est� eMicro:bita la Micro:bit.
El bucle tindr� la seg�ent forma:
6 # Main Loop
7 while True:
8		if accelerometer.was_gesture('shake'):
9			tool = random.randint(0,2)
10		if tool == 0:
11			display.show(Image.SQUARE_SMALL)
12		elif tool == 1:
13			display.show(Image.SQUARE)
14		else:
15			display.show(Image.SCISSORS);
Explicaci� del codi
El codi es compon b�sicament d�una s�rie de bucles if niats entre ells que realitzen una acci� una altre depenen del valor de la variable tool. La variable tool �s una variable de tipus integer (enter) que agafa nombres aleatoris entre 0 i 2 quan es sMicro:bit Micro:bit. Per obtenir aquesta variable s�utilitza el m�tode randint(a,b) del m�dul random de la seg�ent manera:
tool = random.randint(a,b)
on:
* a: �s el valor m�nim que pot agafar la variable tool.
* B: �s el valor m�xim que pot agafar la variable tool.
Un cop s�ha calculat el valor de la variable simplement fem que es mostri una figura o una altre a pantalla depenent del seu valor mitjan�ant un bucle if.
Fent el joc m�s accessible
Si executem el codi, veurem que es por jugar sense cap tipus de problema, aparentment. El joc t� un problema i �s que tal i com est� creat nom�s poden jugar aquelles persones que no tenen una discapacitat visual, i que per tant poden veure el gr�fic de la pantaMicro:bit Micro:bit.
La forma de fer que aquest projecte sigui accessible a les persones a discapacitat visual �s afegint-hi un so. En aquest cas afegirem una veu, la veu de lMicro:bitit dir� que hem tret a la nostra tirada.
Com ja tenim el m�dul speech importat, nom�s ens calen afegir tres l�nies, una a cada bucle if. Aquestes l�nies s�n:
12 speech.say('Pedra')
15 speech.say('Paper')
18 speech.say('Tisora')
Al afegir aquestes l�nies, fem que lMicro:bitit informe el valor de la tirada de cada jugador. Si executem el codi veurem que la veu de lMicro:bitit no �s molt agradable i que �s angles. Aix� pot dificultar una mica la comprensi� del resultat de cada jugador. Per aquest motiu podr�em incloure un so diferent per cada resultat.
Afegint un so
Per afegir un so hem d�importar el m�dul de m�sica. Al bloc dels imports afegirem la seg�ent l�nia:
5 import music
Ara ja podem reproduir un so diferent per cada tirada. El so el reproduirem despr�s de que parli lMicro:bitit. Per fer-ho afegirem les seg�ents l�nies:
14 music.play(music.RINGTONE)
18 music.play(music.JUMP_DOWN)
22 music.play(music.JUMP_UP)
Ara despr�s de dir el que s�ha tret a la tirada s�emetr� un so diferent.
El codi
El codi sencer del projecte es pot consultar a la secci� XXX de l�ap�ndix.


Codi Morse
Introducci�
El codi o alfabet Morse va ser creat per Samuel Morse i es basa en la representaci� de lletres i n�meros mitjan�ant senyals emeses de forma intermitent.
D�aquesta forma, la lletra A es pot transmetre mitjan�ant un punt i un gui�, tal i com es pot veure a la Imatge 1.

Imatge 1 Alfabet Morse.
Objectiu
A aquest projecte farem que la Micro:bit escrigui a pantalla el codi Morse i emeti un so diferent quan pitgem el bot� A (punt) o el bot� B (gui�).
Primers passos
Per crear el nostre projecte comen�arem, com sempre, important els m�duls necessaris, que de moment ser� Micro:bitro:bit. Per tant a la primera l�nia escriurem:
1	from microbit import *
Un cop escrita aquesta l�nia. Comen�arem amb el bucle principal del projecte. Aquest bucle ser� un bucle de tipus while. Els bucle de tipus while s�executen sempre, de manera cont�nua quan la condici� sigui certa, Per fer que un bucle com aquest s�executi indefinidament hem d�assignar-li una condici� True (cert).
La segona l�nia de codi ser� de la forma:
5	while True:
El seg�ent pas ser� assignar una acci� als botons A i B Micro:bitro:bit. Per aix� utilitzarem un altre tipus de bucle, el bucle if. Es podria dir que els bucles if s�n bucles de preses de decisions, una cru�lla a un cam�. Aquest bucle, com el while, nom�s s�executa si la condici� �s certa; en cas que la condici� no sigui certa, llavors s�agafa l�altre cam�, i a difer�ncia dels bucles while, els bucles if nom�s s�executen un vegada, si la condici� �s certa, o cap, en cas de que la condici� sigui falsa.
Aix� doncs, la seg�ent l�nia del nostre codi ser�:
6		if button_a.is_pressed():
El seg�ent pas es escriure el codi que s�executar� en cas de que pitgem el bot� A. Si pitgem el bot�Micro:bitMicro:bit, volem que es mostri a la pantalla un punt. Per fer-ho escriurem:
7			display.show(Image(�00000:�
8						�00000:�
9						�00900:�
10					�00000:�
11					�00000�))
El valor 0 indica que el led de la Micro:bit situat a la posici� tindr� una intensitat 0, o el que �s el mateix, no s�il�luminar�. Per contra, el valor 9 indica que el led situat a aquella posici� tindr� una intensitat m�xima.
Al poder assignar diferents intensitats les leds de la pantalla de la Micro:bit, podem realitzar animacions millors i jugar a fer ombres o animacions millors.
Per �ltim, copiarem el bucle if que acabem de crear i substituirem la lletra a per la lletra b a la condici� del codi i a la files on hem escrit �00900:� escriurem �09990:� per dibuixar una l�nia a la pantalla.
El codi hauria de ser una cosa semblant al seg�ent:
1	# Imports
2	from microbit import *
3	import music
4
5	# Main loop
6	while True:
7		if button_a.is_pressed():
8			display.show(Image('00000:'
9					'00000:'
10					'00900:'
11					'00000:'
12					'00000'
13			))
14
15		if button_b.is_pressed():
16			display.show(Image('00000:'
17					'00000:'
18					'09990:'
19					'00000:'
20					'00000'
21		))
Si ara executem el codi al simulador de la Micro:bit, veurem que quan es pitjar el bit� A apareix un punt al centre de la pantalla, i quan pitgem el B apareix una l�nia de 3 punts. Hem aconseguit escriure els dos signes generadors del codi mors!
Afegint est�muls
Anem pel bon cam�, per� al primer cap�tol hem dit que es busquen projectes que estimulin m�s d�un sentit, i ara mateix nom�s estem estimulant el sentit de la vista. Anem a estimular el sentit de l�o�da.
Per fer-ho, farem que la Micro:bit emeti un so durant un instant quan pitgem el bot� A i el mateix s, el doble de temps, quan pitgem el bot� B. El primer de tot, ser� importar el m�dul music. Per fer-ho escriurem a sota de l�altre import:
3	import music
Ara que hem importat el m�dul, podem comen�ar a utilitzar els seus m�todes. Per emetre una nota escriurem, dins del primer bucle if:
15		music.play(�a�)
El seg�ent pas ser� copiar la l�nia anterior dins l�altre bucle if modificant a per b per produir una nota diferent i permetre a l�o�da diferenciar entre un punt i un gui�.
El codi, amb les modificacions hauria de tenir una forma similar al seg�ent:
1	# Imports
2	from microbit import *
3	import music
4
5	# Main loop
6	while True:
7		if button_a.is_pressed():
8			display.show(Image('00000:'
9					'00000:'
10					'00900:'
11					'00000:'
12					'00000'
13						))
14
15			music.play('a')
16
17		 if button_b.is_pressed():
18			display.show(Image('00000:'
19					'00000:'
20					'09990:'
21					'00000:'
22					'00000'
23						))
24
25			music.play('b')
Si executem el codi al simulador, veurem que al pitjar el botons es mostra a pantalla un dels s�mbols generadors i s�emet un so diferent. Pr�cticament ho tenim enllestit. Hi ha un petit per�.
El per� �s que el punt i el guio resten a pantalla tota l�estona fins que es pitja un altre cop un dels botons, quan hauria d�estar nom�s un temps limitat.
Netejant la pantalla.
Per netejar la pantalla hem d�incloure, just al final dels dos bucles if, o al final del bucle while, les seg�ents l�nies:
26		sleep(500)
27		display.clear()
En el meu cas les he afegit al final del bucle while.
A l�apartat Enviant missatges desenvoluparem aquest codi per enviar un missatge als nostres amics.
Codi
El codi sencer d�aquest projecte es pot consultar a la secci� Codi Morse de l�Ap�ndix.


El batec de la Micro:bit
A molts quaderns de programaci� dMicro:bitit el primer programa a realitzar �s la animaci� del bateig d�un cor. Aquesta activitat t� un problema des del punt de vista de l�accessibilitat. El problema �s que nom�s hi ha un est�mul visual, i per tant, les persones amb una discapacitat visual no poden gaudir plenament l�experi�ncia.
A aquesta activitat, a banda de mostrar un cor bategant a la pantalla de la Micro:bit, s�emetr� un so de bateig, creant d�aquesta forma un est�mul sonor que permetr� als discapacitats visuals gaudir m�s de l�experi�ncia.
Comencem a programar!
El Codi
El codi b�sic d�aquest projecte �s el seg�ent:
1	# Imports go at the top
2	from microbit import *
3
4	# Code in a 'while True:' loop repeats forever
5	while True:
6		display.show(Image.HEART)
7		sleep(500)
8		display.show(Image.HEART_SMALL)
9		sleep(500)
Emetent batecs
Modificarem aquest codi per que la Micro:bit tamb� emeti un so amb les animacions del cor bategant. Per aix� escriurem la seg�ent l�nia:
3	import music
Aquesta l�nia la inserirem a sota de la l�nia de la importaci� inicial, �s a dir, ser� la l�nia 3 del nostre codi.
Ara nom�s hem d�afegir una l�nia a sota de la l�nia de codi on es mostra el cor gran. La l�nia que hem d�afegir �s:
music.play(�a�)
La l�nia s�inserir� a la posici� 8 del codi. Amb tot el codi del projecte quedar� de la seg�ent forma:
1	# Imports go at the top
2	from microbit import *
3	import music
4
5	# Code in a 'while True:' loop repeats forever
6	while True:
7		display.show(Image.HEART)
8		music.play(�a�)
9		sleep(500)
10		display.show(Image.HEART_SMALL)
11		sleep(500)
Explicaci� del codi
Ara que hem vist quina pinta t� el codi, anem a explicar que fa cada l�nia:
1. A les l�nies 1 i 5 introdu�m comentaris per explicar que estem fent a les l�nies seg�ents. A Python els comentaris van precedit del s�mbol #. Tot el que hi hagi escrit a una l�nia darrere d�aquest s�mbol no ser� compilat i es considerar� un comentari.
      Nota: Els comentaris en programaci� es realitzen en angl�s.
2. A les l�nies 2 i 3 importem les llibreries necess�ries per que es pugui compilar el codi que estem escrivint. En aquest cas hem importat dues llibreries:
a. Micro:bit. Per poder utilitzar les llibreries pr�pies dMicro:bitit.
b. Music. Per poder emetre sons mitjan�ant lMicro:bitit.
3. A la l�nia 6 s�inicia un bucle while. Aquest bucle finalitza a la l�nia 11. Els bucles while serveix per executar de forma cont�nua una part de codi sempre que la condici� que els executa sigui certa. En aquest cas hem dit while True. Aquesta condici� ser� sempre certa i per tant, hem creat un bucle infinit que s�executar� de forma cont�nua.
4. A les l�nies 7 i 10 es crida al classe display que cont� el m�tode show(). A aquest m�tode serveix per mostrar una imatge a la pantallMicro:biticro:bit, En aquest exemple es passa la imatge d�un cor gran (a la l�nia 7) i un cor petit a la l�nia 10.
5. A la l�nia 8 es crida a la classe music per utilitzar el m�tode play(). A aquest m�tode se li ha de passar un nombre sencer. En aquest cas li passem el valor 100. Aix� faMicro:biticro:bit emeti una nota a una freq��ncia de 100Hz.
6. A les l�nia 9 i 11 s�imposa un temps d�espera de 500 mil�lisegons. Aquest temps d�espera entre imatge i imatge �s el que crea l�animaci� de batec, al passar cont�nuament d�un cor gran a un petit i d�un cor petit a un gran.
Codi
El codi sencer es pot consultar a la secci� El batec de lMicro:bitit de l�ap�ndix.


Conta enrere
Aquest projecte �s la programaci� d�una conta enrere des de 10 fins a 0. La conta enrere es mostrar� a la pantallMicro:biticro:bit i anir� acompanyada d�una pulsaci�, la mateixa que es va fer al projecte EMicro:bite la Micro:bit, per tenir una estimulaci� sonora a banda d�una visual.
Al projecte es veur� un nou tipus de bucle, un bucle for i es veur� com declarar una variable que utilitzarem per realitzar la conta enrere.
Comencem el conta enrere!
Declarant una variable
El codi de la conta enrera, �s possiblement, m�s senzill que el codi del projecte anterior, encara que tamb� t� les seves peculiaritats. La primera �s la declaraci� d�una variable.
Quan parlem de variables, hem de saber distingir entre una variable d��mbit global i una d��mbit local. De moment, l��nic que cal saber �s que les variables d��mbit global, com la que utilitzarem a aquest projecte, �s declaren just despr�s de la l�nia dels imports i es fa de la seg�ent manera:
[nom variable] = [valor variable]
Un exemple de declaraci� seria:
i = 10
Dit aix�, just a l�inici del nostre projecte escriurem:
1	# Imports go at the top
2	from microbit import *
3	import music
4
5	# Variables
6	i = 10
A la l�nia 6 realitzem la declaraci� de la variable i i el seu valor: 10.
Bucle for
Despr�s de la declaraci� de la variable iniciem el bucle for, que �s el bucle principal del projecte.
8	# Main loop
9	for index in range(11):
10	display.show(i)
11	music.play(�a�)
12	i = i - 1
13	sleep(1000)
Explicaci� del codi
A aquest projecte hem d�explicar el bucle for. Un bucle for s�executa un determinat nombre de cops. Per decidir quants cops s�executa una bucle for es tendeix a incloure un algoritme que modifica el valor de la variable que controla el bucle cada cop que s�executa el bucle. En aquest cas es modifica el valor de la variable i.
A la l�nia 9 declarem el bucle for i establim que s�executar� 11 cops (index in range(11)). Expliquem una mica m�s aquesta darrera sent�ncia:
* index: Es el valor que s�anir� modificant.
* in; vincular index amb el seu rang de valors.
* range(): Indica el rang de valors, o els passos a realitzar pel bucle.
* 11: �s el nombre de cops (passos) que s�executar� el bucle for.
Les l�nies 10 i 11 ja les coneixem del projecte anterior. A la l�nia 12 el que estem fent �s reduir en un valor la variable i cada cop que s�executa el bucle for.
Per �ltim, a la l�nia 13 fem que el codi s�aturi 1 segon abans de tornar-se a executar el bucle for.
Concepte
No ha cridat l�atenci� alguna cosa del codi? Us heu fixat que el valor de la variable i �s de 10 i executem el bucle for 11 cops? Aquesta �incoher�ncia� es deu a que el 0 �s un nombre i per tant s�ha de tenir en compte alhora de programar. Si fem que el bucle for s�executi nom�s 10 cops el darrer nombre que assolir� la variable i ser� 1 i no 0.
Feu la prova!
Codi
El codi sencer d�aquest projecte es pot consultar a la secci�  de l�Ap�ndix.


Programaci� Interm�dia


El foraster m�s r�pid
Introducci�
A aquest projecte farem una combinaci� de dos projectes vists a la secci� de programaci� inicial. Els projectes que combinarem s�n: El m�s r�pid i Conta enrere. Com veurem caldr� realitzar algunes modificacions al codi que ja vist.
Objectiu
L�objectiu d�aquest projecte �s veure com utilitzar bucles dins de bucles (bucles niats). Per fer-ho es mostrar� un exemple amb dos bucles while.
Tamb� es veur� el reaprofitament de blocs de codi mitjan�ant la definici� de funcions.
Afegint un compte enrere
El primer que hem de fer �s afegir la declaraci� d�una variable a sota del bloc dels imports, per� iniciant la variable a 3. D�aquesta forma escriurem:
5	 # Variables
4	i = 3
El seg�ent pas ser� escriure el bucle for dins del bucle while de la seg�ent forma:
7
8	 while True:
9		for index in range(4):
10			display.show(i)
11				music.play(�a�)
12				i = i - 1
13				sleep(1000)
Si executem el codi del projecte veurem que el compte enrere �s infinit, i un cop s�arriba al zero es continua comptant en nombre negatius.
Per que aix� no succeeixi s�ha de fer segon bucle while niat, �s a dir, un bucle while dins un altre bucle while. El codi anterior quedar� de la seg�ent forma:
7
8 while True:
9		while i > 0:
9			for index in range(3):
10				display.show(i)
11				music.play(�a�)
12				i = i - 1
13				sleep(1000)
14		
15				If i == 0:
16					display.show(0):
17					music.play(music.JUMP_UP)
Al niar un bucle while, estem fent que el bucle for s�executi dins el segon bucle while. Aquest segon bucle while nom�s s�executar� quan el valor d�i sigui superior a menys 1 (�1). En el moment en que el valor de la variable sigui zero (0), es mostrar� el valor en pantalla, s�emetr� un so i es sortir� d�aquest bucle while; continuant-se l�execuci� del bucle while inicial.
Una cosa que ens em de fixar �s que ara el rang de i �s tres (3) i no quatre (4) com abans. El rang s�ha disminu�t en un valor per evitar una superposici� de dos sons al arribar al valor de zero (0). Amb aquesta modificaci� s�evita que el zero faci el so de a conta enrere.
Si es vol que el zero (0) formi part de la conta enrere, llavors al bucle if, en lloc de mostrar-se el valor de zero (0) es podria mostrar un text que digu�s JA quan s�emeti el so d�inici del joc.
Ja tenim creada la conta enrere. Si enganxem el codi del projecte a fora del segon bucle while per� a dins del primer, ja tindrem el nostre projecte executant-se de forma adient.
El bucle principal del projecte hauria de tenir la seg�ent forma:
9 while True:
10	while i > 0:
11		for n in range(3): 
12			display.show(i)
13			music.pitch(100) 
14			sleep(1000)
15			i = i - 1
16
17			if i == 0:
18				display.show(0)
19				music.play(music.JUMP_UP)
20
21		if button_a.is_pressed():
22			display.show(Image.ARROW_W)
23			music.play('a')
24			sleep(500)
25
26		elif button_b.is_pressed():
27			display.show(Image.ARROW_E)
28			music.play('b')
29			sleep(500)
Si executem ara el codi del nostre projecte ens cridar� l�atenci� que al pitjar el bot� A o Micro:biticro:bit la fletxa es mostra tota l�estona i si es torna a pitjar una altre cop, la fletxa modifica el seu sentit depenent del bot� pitjar, �s a dir, no es torna a realitzar una conta enrere.
El que es vol �s que es torni a iniciar el conta enrere per tornar a jugar. Anem a veure com ho podem fer.
Reiniciant el compte enrere
El primer que hem de fer �s redefinir el bucle while intern i convertir-lo en una funci�. Les funcions s�n blocs de codi que es poden utilitzar i que s�han de declarar abans de la seva utilitzaci�. Si es declara despr�s de la seva utilitzaci� el programa ens retornar� un error.
Dit aix�, declararem la funci� abans del primer bucle while de la seg�ent forma:
8 def countdown(i):
9 
10	while i > 0:
11		for n in range(3): 
12			display.show(i)
13			music.play(�a�)
14			sleep(500)
15			i = i - 1
16
17			if i == 0:
18			display.show(0)
Ara que tenim la funci� definida, expliquem-la. Per definir una funci� sempre s�utilitzar� la paraula reservada def seguida del nom de la funci�. En el cas anterior seria def countdown( ). Despr�s dels par�ntesis s�han d�escriure dos punts ( : ) que indiquen l�inici de la definici� de la funci�, de igual manera que es fa amb un bucle while, per exemple.
A dins d�aquesta funci� s�ha inserit tot el bucle while que estava niat. Per fer que s�executi la funci� la hem de cridar al bucle principal. Per fer-ho escriurem el nom de la funci� just a sota de l�inic del bucle while i dins d�un bucle if de la seg�ent manera:
23	if i > 0:
24		countdown(i)
25		music.play(music.JUMP_UP)
26		i = 0
El bucle if �s necessari per evitar que la funci� countdown( ) sigui cridada infinitament. El mateix passa amb la igualtat i = 0. Sense aquestes dues l�nies la funci� seria cridada una vegada i un altre fent-se un conte enrere des de 3 fins a 0 de forma infinita.
Ara, per saber si s�ha pitjar el bot� A o B deMicro:bit:bit definirem una funci� a la que se li passar� un valor de 0, si s�ha pitjat el bot� A o un valor 1 si s�ha pitjat el bot� B. Degut que a aquesta funci� se li passa un par�metre, entre els par�ntesis s�ha d�escriure una variable que agafar� el valor que se li passa a la funci�.
La definici� de la funci� ser� de la seg�ent manera:
21	def btn_presed(btn):
22		if btn == 0:
23			display.show(Image.ARROW_W)
24			music.play('a')
25     
26		elif btn == 1:
27			display.show(Image.ARROW_E)
28			music.play('b')
29
30		sleep(1000)
A la variable l�hem anomenat btn, i depenent del valor de btn s�executar� un o altre bloc del bucle if. Ara nom�s ens cal cridar a la funci� a dins del bucle while principal. Al cridar la funci� haurem de passar el valor que es vol que adquireixi la variable btn. La crida la farem dins d�un bucle if contingut al bucle principal while de la seg�ent manera:
39	if button_a.is_pressed():
40		btn_presed(0)
41	elif button_b.is_pressed():
42		btn_presed(1)
Si estudiem aquest bloc de codi, veiem que quan es pitja el bot� A la funci� btn_pressed( ) se li passa el valor 0, i si es pitja el bot� B se li passa el valor 1. D�aquesta forma, la variable btn agafa un valor o un altre depenent del bot� que es pitgi.
Encara hem de realitzar una modificaci�. Si intentem cridar a les funcions ja creades de forma reiterativa es veur� com el bucle principal s�executa de forma indefinidament. Per evitar aix� hem de crear una nova funci� que s�activi quan els jugadors realitzin una accMicro:bitla Micro:bit. En aquest cas s�ha triat un sacseig de la mateixa.
La definici� de la funci� seria:
32	def on_shake(i):
33		if accelerometer.is_gesture('shake'):
34			if i > 0:
35				countdown(i)
36				music.play(music.JUMP_UP)
37				i = 0
A aquesta funci� se li passa un valor que �s agafat per la variable i. A la funci� es crida a la funci� countdown( ). Aquesta crida es realitzar� si el valor de la variable i �s superior a 0. Un cop la variable assoleix el valor de 0 es produeix el so i es surt de la funci�.
Al haver-se creat aquesta nova funci�, ara hem de cridar-la des de l�interior del bucle while principal de la seg�ent manera:
40 while True:
41	on_shake(3)
Bucle while principal
Amb totes aquestes modificacions el bucle while principal he de tenir la seg�ent forma:
40	while True:
41		on_shake(3)
42
43		if button_a.is_pressed():
44			btn_presed(0)
45		elif button_b.is_pressed():
46			btn_presed(1)
Tal i com est� ara mateix el bucle principal del nostre projecte estem fent que el joc sigui infinit. Per modificar aquest comportament hem de crear una variable nova que anir� sumant o restant valors cada cop que s�executi el bucle. D�aquesta forma podrem fer que el bucle s�executi un nombre determinar de vegades.
Aix� doncs, definim una variable global:
5 # Variables 
6 game = True
7 turns = 5
I modificar la condici� d�execuci� del bucle while segons el valor de la nova variable:
43	while game:
Ara, per fer que el bucle finalitzi hem de sumar un valor cada cop que executem el bucle sencer. Ara, dins de cada bucle if, al final, escrivim la sent�ncia: turns = turns -1. D�aquesta forma, cada cop que pitgem un dels botons deMicro:bit:bit es reduir� en 1 el valor de la variable turns.
Aix� ho farem mitjan�ant un bucle if.
61	if turns == 0:
62		game == False
Dient el guanyador
El joc ja �s funcional i es poden jugar 5 torns, per� no hi ha un marcador ni un guanyador. Anem a afegir-ho.
El primer que farem ser� importar el m�dul speech per fer queMicro:bit:bit digui qui ha guanyat. Al bloc dels imports afegirem:
4 import speech
Tamb� hem d�afegir dues variables al bloc de les variables.
9 player_a = 0
10 player_b = 0
A aquestes dues variables guardarem el marcador del jugador a (player_a) i el del jugador b (player_b).
Ara, nom�s ens manca incrementar el marcador del jugador m�s r�pid en cada torn. Per fer-lo a l�interior del bucle if del bot� A afegirem:
52		player_a = player_a + 1
I a dins del bucle if del bot� B:
58		player_b = player_b + 1
Amb aix� ja hem aconseguit el nostre marcador. Ara nom�s manca que es mostri al finalitzar la partida.
Per fer-ho modificarem el darrer bucle, on es finalitza la partida, afegint les seg�ents l�nies:
65	if player_a > player_b:
66		display.show(�A�)
67		speech.say(�jugador A gana�)
68	elif player_b > player_a:
69		display.show(�B�)
70		speech.say(�jugador B gana�)
D�aquest forma hem finalitzat el joc del pistoler m�s r�pid. Les partides han estat programades per 5 torn. Si volem jugar m�s torns nom�s hem d�incrementar el valor de la variable turns.
Codi
El codi sencer del projecte es pot consultar a l�apartat El foraster m�s r�pid de l�ap�ndix.

Un contra l�altre
Objectiu
A aquest projecte reprendrem el projecte Pedra, paper, tisora i el retocarem per enviar el resultat d�unMicro:bitit a una altre i aix� saber qui �s el guanyador mitjan�ant un missatge verbal i una m�sica.
Per connectar les dues Micro:bit, com veurem, ens caldr� importar el m�dul de r�dio i fer alguns configuracions, per� no ens avancem i anem a a millorar el joc!
Important el m�dul radio
Com sempre que volem utilitzar un m�dul de lMicro:bitit que encara no hem utilitzar, hem d�importar-ho al bloc dels import. A aquest bloc afegirem la seg�ent l�nia:
6 import radio
Un cop importat aquest m�dul, ja el podem utilitzar per connectar les dueMicro:bitit.
Creant un grup
Per poder connectar dues o m�Micro:bitit hem de crear un grup de connexi�. La creaci� d�un grup fa que noMicro:biticro:bit que pertanyin al grup es connectin entre elles, deixant a la resta fora del grup i evitant interfer�ncies. D�aquesta forma es poden realitzar partides simult�nies si modifiquem el nom del grup.
Els grups s�anomenen amb un n�mero; per tant, utilitzant un s�mil a radiof�nic, es podria dir que modifiquem la freq��ncia d�emissi� i recepci� utilitzant diferents canals. Per crear un grup escriurem, just a sota de l�inicia del bucle principal while el seg�ent:
11	radio.config(group=12)
En aquest cas hem assignat el n�mero 12, per� es pot assignar qualsevol altre n�mero entre 0 i 255.
Enviant i rebent informaci�
Ara que hem establint un grup, podem connectar les Micro:bit. Per fer-ho, just despr�s del darrer bucle if escriurem:
30	radio.send(str(tool))
31	recieved=radio.receive()
32	result = ''
A la l�nia 30 estem enviant la variable tool a l�alMicro:bit:bit; a la 31 estem rebent l�enviament de l�Micro:bitro:bit i assignant el valor a una nova variable anomenada recieved. A la darrera l�nia creem una nova variable buida anomenada result que utilitzarem m�s endavant. Recordem que aquestes noves variables son locals.
El seg�ent pas �s la creaci� de bucles if niats per la pressa de decisions depenent dels valors de les variables tool i recieved.
Pressa de decisions
Per la pressa de decisions niarem diferents bucles if. Al bucle if m�s extern valorarem la variable tool i a l�interna la variable recieved de la seg�ent manera:
35	if tool == 0:
36		if recieved == "1":
37			result = 'Perds'
38		elif recieved == "2":
39			result = 'Guanyes'
40	elif tool == 1:
41		if recieved == "0":
42			result = 'Guanyes'
43		elif recieved == "2":
44			result = 'Perds'
45	elif tool == 2:
46		if recieved == "0":
47			result = 'Perds'
48		elif recieved == "1":
49			result = 'Guanyes'
En aquest cas no podem utilitzar l�operador l�gic & per resoldre la presa de decisions degut a que la variable tool �s un integer (enter) i la variable recieved �s un string (cadena). Per aquest motiu no es pot realitzar una comparaci� de variables.
Com veiem al codi anterior, la nova variable result est� prenent el valor del resultat de la comparaci� entre les variables tool i recieved.
Tria del guanyador
Ara amb el valor de la variable result mostrarem a pantalla i amb so qui dels dos jugadors ha guanyat. Per realitzar aix� utilitzarem un bucle if de la seg�ent manera:
51	if result == 'Guanyes':
52		display.show(Image.SMILE)
53		music.play(music.PYTHON)
54		speech.say('Guanyes')
55	elif result == 'Perds':
56		display.show(Image.SAD)
57		music.play(music.FUNERAL)
58		speech.say('Perds')
59	elif result == 'Empatas':
60		display.show(Image.ASLEEP)
61		music.play(music.WAWAWAWAA)
62		speech.say('Empat')
Amb aquest darrer bucle tindr�em un projecte operatiu. Si veiem el codi, aquest �s ara mateix una mica conf�s i brut. Aix� que anem a netejar-ho.
Netejant el codi
El primer que farem ser� esborrar les l�nies on reprodu�m un so quan apareix el resultat a pantalla, �s a dir, les l�nies 18, 22 i 26. Ara ja no cal que s�emeti un so diferent depenent del valor de la tirada. Realment tamb� podr�em treure les l�nies 17, 21 i 25; per� les deixarem per que el jugador s�piga quin �s el valor de la seva tirada.
Una altre cosa que es pot realitzar per netejar el codi i fer-ho m�s entenedor �s crear funcions per agrupa diferents blocs de codi. D�aquesta forma crearem una funci� anomenada Trie( ) a la que se li passar� la variable tool.
La definici� de la funci� es realitzar� abans del bucle while de la seg�ent manera:
8 # Functions
9 def Trie(tool):
10	if tool == 0:
11		display.show(Image.SQUARE_SMALL)
12		speech.say('Pedra')
13	elif tool == 1:
14		display.show(Image.SQUARE)
15		speech.say('Paper')
16	else:
17		display.show(Image.SCISSORS);
18		speech.say('Tisores')
Al lloc on estava aquest bloc de codi cridarem a la funci�:
28	Tries(tool)
Podem fer el mateix amb els altres dos bucles i crear dues noves funcions, que anomenarem Comparison( ) i Winner( ). A la primera funci� realitzarem la comparaci� de les variable i retornarem el valor de la variable result.
Aquesta primera funci� l�escriurem just a sota de la funci� Tries(tool) i ser�:
20 def Comparison(tool, recieved):
21	result = ''
22
23	if tool == 0:
24		if recieved == "1":
25			result = 'Perds'
26		elif recieved == "2":
27			result = 'Guanyes'
28	elif tool == 1:
29		if recieved == "0":
30			result = 'Guanyes'
31		elif recieved == "2":
32			result = 'Perds'
33	elif tool == 2:
34		if recieved == "0":
35			result = 'Perds'
36		elif recieved == "1":
37			result = 'Guanyes'
38
29	return result
Com podem veure a la definici� de la funci�, se li passen dues variables: tool i recieved. El m�s important d�aquest funci� �s retorn de la variable result. Aquesta variable es retorna al final de la funci�.
Com que la funci� Comparison(tool, recieved) retorna un valor, al cridar a la funci� des del bucle principal while, s�ha d�assignar aquest valor a una variable a l�hora de realitzar la crida. Per aquest motiu, la funci� es cridar� de la seg�ent forma:
72	result = Comparison(tool, recieved)
Al cridar-se d�aquesta forma, el valor de la variable retornada s�assigna a la variable de nova definici� result. En aquest punt s�ha de fer un inc�s, encara que les variables es diuen igual: result, s�n dues variables diferents. La variable result que es defineix a dins de la funci� Comparison(tool, recieved) nom�s existeix dins de la funci�, no fora de la mateixa. Per contra, la variable result que es defineix a l�interior del bucle while, nom�s existeix a l�interior d�aquest bucle, i a cap lloc m�s. �s el cicle de vida de les variable el que ens permet fer aquesta acci�. Per aquest motiu s�ha de tenir sempre molt ben establert i definit quan una variable �s global i quan local i quan utilitzar una variable local o una global.
Enviant la resposta
Tal i com est� definit el codi, la resposta s�envia autom�ticament despr�s de fer la tirada, i a vegades, si no s�ha fet alhora o ha passat molt de temps entre una i una altre es poden produir errors. Per aquest motiu, modificarem el codi per enviar el resultat de la tirada amb un gest. En aquesta ocasi� s�ha triat el gest de tocMicro:bito de Micro:bit.
Per poder fer aix� la variaci� que hem de fer al codi, es la crida a les funci� d�enviament mitjan�ant un bucle if:
69	if pin_logo.is_touched():
70		radio.send(str(tool))
71		recieved=radio.receive()
72
73		result = Comparison(tool, recieved)
74
75		Winner(result)
Amb aquestes modificacions ja tenim el codi m�s polit i entenedor, per� tenim un gran problema: podem fer trampes!
Evitant les trampes
Tal i com tenim definit el codi del projecte hi ha la possibilitat de realitzar trampes i enviar una tirada que sabem que guanyar�. Per evitar aix� podem utilitzar un bucle if. El que farem ser� crear una nova variable global anomenada turns que definirem just abans que el bloc de funcions.
8 # Variables
9 turn = True
El seg�ent pas es modificar el bucle if on es realitza la tirada de la seg�ent manera:
65	if accelerometer.was_gesture('shake') & turn:
D�aquesta manera el bucle if nom�s s�executar� si les dues condicions s�n certes. Ara, per molt que es realitzi el moviment per una nova tMicro:bit Micro:bit no donar� cap nou resultat.
El seg�ent pas es treure tot el bucle if on es mira la condici� de si s�ha tocat el loMicro:bitro:bit fora del bucle de la tirada. Al fer-ho sens marcar� que no existeix la variable tool. Aix� es deu a que aquesta variable �s una variable local. La soluci� �s fer que la variable passi a ser global definint-la just a sota de la variable turn.
10 tool = 10
Amb aquestes modificacions el nostre joc ja funciona de forma correcta, per� hi ha un petit inconvenient, nom�s podem jugar una partida. Si es vol fer una segona partida s�ha de reiniciMicro:bitro:bit. Anem a solucionar-ho!
M�s d�una partida
Per solucionar aquest fet, el m�s senzill �s crear una nova funci� que anomenarem Clean( ) on reiniciarem totes les variables.
A sota la darrera funci� definida escriurem:
60 def Clean(tool, turn, result):
61	tool = 10
62	turn = True
63	result = ''
Com es veu, ja aprofitem la nova funci� per reiniciar totes les variables al seu valor inicial.
Ara nom�s manca cridar a aquesta funci� al final del tot el bucle on enviem la tirada al nostre oponent. Abans de la crida farem que hi hagi una pausa d�uns 2 segons per que els jugadors puguin discutir el resultat de la tirada.
86		sleep(2000)
87
88		Clean(tool, turn, result)
Codi
El codi sencer del projecte es pot veure a la secci� XXX de l�ap�ndix.


Missatge secret
Objectiu
A aquest projecte una continuaci� el projecte de Codi Morse i el modificarem per que aparegui a la pantalla el text escrit quan sacsegem lMicro:bitit. Per fer aix� ens caldr� declarar una constant on hi ha la conversi� de l�alfabet braille a l�alfabet occidental i crear dues variables de tipus array (llista) on anar emmagatzemant els punts i les ratlles i a una altre les lletres introdu�des per formar la paraula.
Comencem!
Creant una constant
Les constants s�n valors que no es modifiquen al llarg d�un codi i es solen escriure en lletres maj�scules per diferenciar+-les de les variables. Al igual que les variables, hi ha diferents tipus de constants.
En el nostre cas utilitzarem un diccionari. Els diccionaris permeten el retorn d�un valor segons els valor que introdueixis, �s a dir, hem d�introduir una clau i un valor.
Per exemple:
�.-�: �A�
En aquest cas, quan la Micro:bit detecti a que la variable letter te al seu interior el valor .- (punt i gui�) ens retornar� la lletra A.
El diccionari que necessitarem �s el seg�ent:
6	# Constant
7	ALPHABET = {
8	 ".-":�A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K�,".-..": "L", "--":"M", "-.":"N", "--.--":"�", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z",
9	 }
Creant les variables
Sobre les variables s�ha de tenir n conte que hi ha variables globals i variables locals. La difer�ncia entre unes i altre �s el seu �mbit, el que vindria a ser una esp�cie de zona d�influ�ncia. Les variables globals les declararem sempre a sota de les importacions, i es poden utilitzar a tot el codi del projecte.
Una variable local seria aquella que hem declarat a dins d�un bucle, per exemple. Aquest variable nom�s es pot utilitzar a dins d�aquest bucle, ja que fora del mateix la variable delcara no existeix.
A sota dels imports escriurem:
13	# Variables
14	letter = ��
15	word = ��
Les variables que hem creat s�n del tipus string (cadena),. Als projectes dMicro:bitit no cal declarar quin tipus de variable estem utilitzant. Per aquest motiu cal inicialitzar-les. �s a dir, donar un valor per defecte a les variables. Al fer-ho s�est� indicant, de forma indirecta, quin tipus de variable volem utilitzar.
Ara que tenim declarades les variables, anem a utilitzar-les. El primer que farem ser� emmagatzemar el valor de � (punt) si pitgem el bot� A, o de - (gui�) si pitgem el bot� B. Per fer-ho, a dins del bucle if del bot� A escriurem:
20			letter = letter + '.�)
I a dins del bucle if del bot� b escriurem:
39			letter. = letter + ('-')
Amb aix� estem emmagatzemant el codi que crear� la lletra a la variable letter. Per� no estem convertint els punts i guions en lletres. Per fer-ho primer hem d�indicMicro:biticro:bit que ja em introdu�t el codi d�una lletra.
Transformant lletres
Per indicar que ja hem codificat una lletra en codi Morse utilitzarem un gest. En aquest cas s�ha decidit utilitzar un d�aquest dos gestos:
* Inclinar la Micro:bit cap a la dreta.
* Inclinar la Micro:bit cap a l�esquerra.
Aquest bucle if l�escriurem just a sota del bucle del bot� B un bucle al que s�accedir� tant si gMicro:biticro:bit cap a la dreta com si la girem cap a l�esquerra. El bucle tindr� la seg�ent forma:
42	if accelerometer.was_gesture('left') | accelerometer.was_gesture('right'):
Per indicar que el bucle s�executi quan lMicro:bitit s�inclini cap a la dreta o cap a l�esquerra hem d�utilitzar l�operador l�gic | (o). A l�interior d�aquest bucle declararem un altre bucle if on es comprovar� si existeix el codi Morse a la constant ALPHABET. I en cas de que existeixi afegirem la lletra a la variable word.
Per fer-ho escriure:
44			word = word + ALPHABET[letter]
A aquest l�nia estem indicant que s�afegeixi a la variable word la transcripci� del codi Morse a lletra definida a la constant ALPHABET segons la codificaci� Morse de la variable Letter.
Per poder anar introduint lletres a la variable letter, hem de reinicialitzar. Aix� ho farem assignant-li un valor buit un cop hem afegit la lletra a la variable word de la seg�ent manera:
45				letter = ��
El seg�ent pas ser� afegir una indicaci� sonora en cas de que s�hagi realitzat la transcripci� de forma correcte. Per aix� afegirem un est�mul sonor. A sota de la l�nia anterior afegirem:
46				music.play(music.POWER_UP)
Ara nom�s ens manca afegir la part del bucle if per si el valor de la variable letter no est� continguda al la constant ALPHABET. Per aix� escriurem:
47		else:
48			music.play(music.POWER_DOWN)
D�aquest forma indicarem que el codi Morse que s�ha introdu�t no correspon a cap lletra.
Mostrar el missatge amagat
Ara nom�s ens manca que alg� pugui veure si escoltar el missatge amagat que ens han deixat escrit aMicro:bit:bit. Per mostrar el missatge s�ha triat el gest de sacsejMicro:bitro:bit. Al fer el geMicro:bitro:bit ens mostrar� per pantalla el missatge i tamb� en dir�.
Per que la Micro:bit parli, al bloc dels imports hem d�importar el m�dul speech.
4	 import speech
El bucle tindr� la seg�ent forma:
54	if accelerometer.was_gesture(�shake�):
55	display.show(word)
56	speech.say(word)
57	word = ��
Com sempre, al final del bucle netegem la variable word per poder deixar una resposta a la Micro:bit.
Codi
El codi sencer del projecte es pot veure a la secci� Missatge Secret de l�ap�ndix.

      Atac de cor a la Micro:bit
Introducci�
A aquest projecte modificarem el projecte El batec de la Micro:bit. Aquesta primera pr�ctica es divideix en dues parts, una primera on es veur� com treballar amb variables i una segona on es veure com utilitzar bucles una mica m�s complicats al no ser sempre cert (True). Tamb� s�incorporen dos nous bucles a la l�gica del projecte.
Modificaci� del Codi
La primera modificaci� que realitzarem ser� la definici� de dues variables: a i b. La definici� de les variables sempre la farem a la part superior del codi, just a sota de les importacions de les diferents llibreries.
Aix� dos afegirem les seg�ents l�nies:
5 # Variables
6	 a = 500
Si mirem el codi antic, ens adonarem que a pren el mateix valor que el valor que es va introduir al m�tode sleep( ) i que b pren el valor que es passa al m�tode play( ). Aix� doncs hem de substituir el valor de 500 per a i el de 100 per b dins del m�todes, quedant de la seg�ent forma les l�nies:
12	music.play(�c�)
13	sleep(a)
Si ara testem el codi a l�emulador, veurem que no hi ha cap modificaci� en el comportament. El cor continua bategant i el so es continua produint. El seg�ent pas �s modificar el valor de a quan l�usuari realitza alguna acci� concreta.
Pitjant botons
L�acci� triada per modificar els valors de a, en aquest cas, ha sigut la de pitjar el bot� A Micro:bitro:bit. Per aix� utilitzarem un bucle if.
A la l�nia 17 introduirem el seg�ent codi, dins del bucle while:
17		if.button_a.is_pressed():
18			a = a + 50
Mitjan�ant aquest bucle estem indicant a lMicro:bitit que cada cop que l�usuari pitgi el bot� A Micro:bitro:bit el valor d�a s�incrementar� en 50. Si ara testem el codi veurem que al anar pitjant el bot� A el batec del cor es va accelerant de forma uniforme.
Ja estem m�s a prop d�aconseguir un atac al cor. El seg�ent pas ser� la modificaci� del bucle while.
Modificant la condici� de while
Ara hem de modificar la condici� del bucle while de tal forma que quan a arribi a un valor donat es surti del bucle. En aquest cas hem triat quan a sigui inferior a 50.
Ho farem de la seg�ent forma:
10	while a < 50:
D�aquesta manera s�est� indicant que quan el valor d�a sigui superior a 50 s�executi el codi a l�interior del bucle while, per� que quan sigui inferior es surti del bucle.
Si ara testem el codi, veurem que quan a assoleix el valor de 50 s�atura l�execuci� del codi. Ara nom�s ens manca introduir un codi que diguiMicro:biticro:bit ha mort. Per fer aix� introduirem codi fora del bucle while, que s�executar� quan el valor d�a sigui inferior a 50.
Codi de mort
Fora del bucle while nom�s ens manca incorporar 3 l�nies de codi per indicar queMicro:bit:bit ha mort. A partir de la l�nia 20 escriurem:
20	music.play(�c�)
22	display.show(Image.SKULL)
Al codi modifiquem el cor que aparegui a la Micro:bit, per una calavera per indicar que la Micro:bit ha mort d�un atac al cor.
Codi
El codi es pot consultar a la secci� Atac de cor a lMicro:bitit de l�ap�ndix.


Programaci� Avan�ada


El pistoler m�s r�pid
Introducci�
Tenir dos jugadors amb una �nicMicro:bitit pot ser angoixant i poc pr�ctic. Per aquest motiu, a aquest projecte es modificar� el codi vist a El foraster m�s r�pid i permetre realitzar una partidMicro:bit Micro:bits.
En aquest cas donar� igual el bot� que es pitgi i Micro:bit:bits es connectaran per r�dio per saber qui ha guanyat.
Connexi� per r�dio
Per poder connectar dues Micro:bits per r�dio el primer que s�ha de fer �s importar el m�dul de r�dio. Per aquest motiu, al bloc dels imports escriurem:
5 import radio
Ara ja podem utilitzar el m�dul per connectar leMicro:bitits. Per fer-ho definirem una nova funci� a sota de la darrera funci� i just abans del bucle principal.
Connectant les Micro:bits
La funci� per connectar leMicro:bitits estar� composta de dues l�nies i ser� de la forma:
38 def players_paring():
39	radio.on()
40	radio.config(group=4)
A aquest funci� estem encenent la r�dio i creant un grup de connexi�. En aquest cas al grup li hem donat l�identificador de 4, per� no vol dir que s�hagin deMicro:bit 4 Micro:bits al grup. El nombre vindria a ser el canal de connexi�Micro:bit de Micro:bits.
Ara ja tenim les Micro:bits aparellades. A aquesta funci� no la cridarem des de el bucle while principal, la cridarem des de la funci� on_shake( ). Que ara ser� de la forma:
26 def on_shake(i, press):
27	if accelerometer.is_gesture('shake'):
28		players_pairing()
29
30		if i > 0:
31			countdown(i)
32			music.play(music.JUMP_UP)
33			i = 0
34			press = True
35
36	return press
Com podem veure, hi ha una nova variable anomenada press i s�han eliminat les variables: game, turns player_a i player_b. Tamb� s�ha eliminat la funci� btn_pressed(btn, result).
Al haver modificat la funci� on_shake(3, press) i retornar una variable, es cridar� a la funci� assignant-li el valor de la variable retornada segons:
44	press = on_shake(3, result)
Tamb� modificarem els bucles if quan es pitja un dels botons. Esborrarem els dos bucles anteriors i definirem un �nic que s�activar� es cas de pitjar un o un altre bot�.
46	if (button_a.is_pressed() | button_b.is_pressed()) & press:
Aquest bucle s�executar� si es pitjar el bot� A o B i sempre i quan s�hagi sacsMicro:biticro:bit un cop. Aquesta acci� es controla mitjan�ant el valor de la variable press. Quan aquesta �s certa (True) es pot executar el bucle; si no ho �s, no es podr� executar el bucle.
A dins del bucle escriurem el seg�ent bloc de codi:
47		radio.send('0')
48		press = False
49		msg = False
50		winner = True
51		music.play('b')
Com es pot observar al bloc de codi superior, hi ha noves variables. Anem a veure les seves funcions.
Les noves variables
La variable press ja l�hem explicat. Aquesta variable ens permet bloquejar la funci� de pitjar els botons A i B.
La variable msg �s una nova variable, que hem de declarar just a sota de la variable press i que se li assignar� un valor de True. Aquesta variable fa que no es pugui tornar a sacsejarMicro:bit:bit per realitzar una altre tirada fins que no s�hagi finalitzat la tirada actual.
Per �ltim, la variable winner, que es defineix amb un valor inicial de False, la definici� es realitza sota de la variable msg. Aquesta variable serveix per enviar un missatgeMicro:bit:biMicro:bit:bit i bloquejar l�enviament en cas de rebre un missatge. Aix� ho veurem al seg�ent bloc.
Rebent un missatge
El seg�ent bloc de codi el que fa es veure si hem rebut un missatge. En cas de rebre el missatge, el primer que es fa �s bloquejar el codi per evitar que l�altre jugador pugui enviar un missatge. Aix� es far� modificant el valor de la variable msg. El seg�ent pas es mirar el valor de la variable press i depenent del mateix mostrar� una cara i emetr� un so o un altre.
53	if radio.receive():
52		msg = False
53
54		if press:
55			display.show(Image.ANGRY)
56			music.play(music.POWER_DOWN)
Guanyador de la tirada
Al bloc on es mostra que s�ha guanyat la partida s�accedeix depenent del valor de la variable winner. El que far� aquest bloc �s mostrar una cara somrient y una m�sica alegra.
60	if winner:
61		score = score + 1
62		display.show(Image.HAPPY)
63		music.play(music.POWER_UP)
Reiniciant el joc
Ara ja tenim el joc funcionant i es pot decidir qui ha guanyat la tirada, per� haur�em de fer un joc m�s llarg, on hi hagin al m�nim cinc (5) tirades i dir qui �s el guanyador la partida. EL guanyador, ser� el primer que arribi a tres (3) tirades guanyadores.
Per tant, el que hem de fer es emmagatzemar alguns valors i reiniciar algunes variables per poder tornar a executar el joc. La reinicialitzaci� es realitzar� si es porten menys de cinc (5) tirades.
65	if pin_logo.is_touched():
66		rounds = rounds + 1
67
68		if rounds < 5:
69			msg = True
70		else:
71			if score >= 3:
72				speech.say('Guanyes')
73				display.show(Image.FABULOUS)
74				music.play(music.PYTHON)
75			else:
76				speech.say('Perds')
77				display.show(Image.SKULL)
78				music.play(music.FUNERAL)
Ara ja nom�s ens queda gravar el codi a dueMicro:bitits i iniciar una partida!
El codi
El codi d�aquest projecte es pot veure tot sencer a la secci� El pistoler m�s r�pid de l�ap�ndix.

Tria tu
Introducci�
   Aquest projecte �s un pas m�s del projecte anomenat Un contra l�altre. A l�anterior projecte era l�atzar qui triava entre pedra, paper i tisora. A aquest �s el jugador el que triar� la seva tirada mitjan�ant alguna d�aquestes accions:
* Pitjar el bot� A.
* Pitjar el bot� B.
* Pitjar el logo de Micro:bit.
Aix� que... anem a modificar el codi!
Substituint el bucle if accelerometer.was_gesture('shake') & turn
El primer que hem de fer �s agafar tot el que hi ha dins el bucle on iniciem la tirada i crear tres (3) bucle nous.
Els bucles nous miraran si s�ha pitjat el bot� A, el B o el logo deMicro:bit:bit per veure quina tirada ha decidit efectuar el jugador. Els bucles tindran la seg�ent forma:
69	if button_a.was_pressed() & turn:
70		turn = False
71		tool = 0
72
73		Trie(tool)
74
75	elif button_b.was_pressed() & turn:
76		turn = False
77		tool = 1
78
79		Trie(tool)
80
81	elif pin_logo.is_touched() & turn:
82		turn = False
83		tool = 3
84
85		Trie(tool)
86
87	sleep(500)
Amb aquesta modificaci� estem fent que el jugador trii la seva jugada i que no sigui l�atzar qui la trii per ell.
Modificant la condici� d�enviament
La seg�ent modificaci� a realitzar ser� el gest d�enviament. Al projecte anterior utilitz�vem el gest de tocar el lMicro:bit Micro:bit; ara aquest gest �s triar les tisores com tirada. Al tenir disponible el gest de Micro:bitla Micro:bit, utilitzarem aquest gest per enviar la nostra tirada al contrincant. Per tant la condici� del bucle quedar� de la seg�ent manera:
92	if accelerometer.was_gesture('shake'):
Amb aix� ja tindr�em finalitzat el nostre projecte. Per� realitzar una �nica partida �s una mica trist, aix� que anem a desenvolupar una mica m�s el codi per que guanyi el millor a 5 tirades.
Afegint un comptador
El que farem per afegir dos comptadors. Per aix� crearem dues noves variables: count i points. A la primera variable es contaran les tirades que no s�n empats i a la segona les tirades que em guanyat.
11 count = 0
12 points = 0
Un cop creades les variables, a dins del bucle on enviem la tirada i abans d�esborrar totes les variables, funci� Clean( ), escriurem:
103		if result != 'Empatas':
104			count = count + 1
Amb aquest bucle estem incrementant el valor de la variable count quan no es produeix un empatat.
Contant tirades guanyades
Les tirades guanyadores, les anirem sumant a la variable points. Per fer-ho crearem un bucle a dins del bucle on s�envia la tirada a l�oponent.
98		if result == 'Guanyes':
99			points = points + 1
Ara, si guanyem sumarem un punt al nostre marcador.
Proclamant un guanyador
El seg�ent pas ser� anunciar el guanyador de la partida. Per fer-ho es mirar� qui t� m�s de 3 vict�ries un cop s�han realitzat les 5 tirades. Aix� es far� mitjan�ant un bucle if dins del bucle on es valora que la variable count ha arribat a 5, de la seg�ent manera:
113		if points > 2:
114			display.show(Image.HAPPY)
115			speech.say('Guanyes')
116			music.play(music.PYTHON)
117		elif points < 3:
118			display.show(Image.SKULL)
119			speech.say('Perds')
120			music.play(music.FUNERAL)
Com podem observar, estem utilitzant imatges i sons que hem utilitzat dins la funci� Winner( ). Aquest fet �s contraproduent pels usuaris, ja que al rebre una informaci� diferent amb el mateix so i la mateixa imatge que una vict�ria parcial, pot pensar que simplement ha guanyat la tirada i no la partida. Per aquest fet, s�han de modificar els sons i les imatges dins la funci� Winner( ).
El codi
El codi complet del projecte es pot veure a la secci� Tria tu de l�ap�ndix.


Enviant un missatge
Objectiu
A aquest projecte tornarem a modificar el codi del projecte Missatge secret per enviar un missatge entre dues Micro:bit i que una altre persona el pugui llegir.
Per aix�, ens caldr� realitzar una connexi� entre lesMicro:bitro:bits.
Enviem missatges!
Imports
Als imports que ja ten�em afegirem el que permet connectar dueMicro:bitit. Aix�, a sota de la darrera l�nia del bloc d�imports afegirem:
5 import radio
El seg�ent pas ser� crear un gest per enviar el missatge escrit. Per fer-ho utilitzarem el gest de sacsejarMicro:bit:bit.
Enviant el missatge
Per enviar el missatge esborrarem el codi escrit a dins del bucle per mostrar el missatge i el substituirem per:
56		radio.send(word)
57
58		if radio.receive():
59			msg = radio.receive()
60
61			if msg:
62				display.scroll(msg)
63				speech.say((msg))
Amb aquest codi estem enviant el missatge escrit per un usuari i rebent-lo a l�altrMicro:bitit. Un cop es rep el missatge lMicro:bitit el mostra en pantalla i el llegeix.
El codi
El codi complert del projecte es pot veure a la secci� Enviant un missatge de l�ap�ndix.


El cor de la Micro:bit
Introducci�
A aquest projecte reprendrem el projecte Atac de cor a la Micro:bit que vam veure a Programaci� Interm�dia. Ara complicarem una mica m�s el codi al imposar condicions variables mitjan�ant l��s de l�gic i utilitzarem elMicro:bite la Micro:bit per alentir el batec del corMicro:bite la Micro:bit pugui morir per un atac de cor o per una aturada card�aca.
El cor
El cor hum� fa, de mitja, entre 60 i 100 batecs per minut. Per tant, el primer que farem �s modificar el ritme cardiaqui del nostre projecte. Al projecte est�vem fent que el cor bategu�s cada 500 mil�lisegons, aix� �s 2 batecs cada segon. Volem que el cor ara bategui 80 cops per minut, �s a dir, 1.3 cops per segon o 1.3 cada 1000 mil�lisegons.
Batecs/Minut
Batecs/SegonsMicro:bit
Freq��ncia
60
1
1
80Micro:bit
1.33
0.75Micro:bit
100Micro:bit
1.67
0.6
Taula 1Batecs de cor per minut, segon i freq��ncia.
Al codi no podem dir que aparegui 1.3 cops cada 1000 mil�lisegons. Per tant, hem de realitzarMicro:bitersi�. Podem fer que aquesta conversi� la realitzi la Micro:bit si la codifiquem al nostre codi. Per� per fer-ho, abans hem de pensar en l�algoritme (funci�) necessari. Pensem!
Tenim 1.3 batecs cada 1000 mil�lisegons i volem saber cada quants mil�lisegons es realitza 1 batec. Per tant:
1.33batecs/(1000 Mil�lisegons)=1batec/(X Mil�lisegons)Micro:bit
X=1000/1.3
X=769.23
�s a dir, la Micro:bit far� 1 batec cada 769.23 mil�lisegons.
Modificant el codi
El primer pas ser� la modificaci� del valor de les variables per simular el batec d�un cor a la Micro:bit segons el batec d�un cor hum�.
Tal i com hem vist al punt anterior, el nou valor de la variable a ha d��sser 769.23 i b 75, que �s la freq��ncia corresponent a 80 batecs/minut. D�aquesta forma hem replicat el batec d�un cor hum� a la nostre Micro:bit.
Aix� doncs, les l�nies 6 i 7 quedaran de la forma:
6	a = 769.23
7	b = 75
El seg�ent pas ser� crear un nou bucle per reduir el batec del cor si l�usuari pitja el bot� B de la Micro:bit.
Reduint el batec
Per reduir el batec del cor crearem un bucle if molt similar al que es va crear per bot� A de la Micro:bit (l�nia 17). A la l�nia 21 escriurem:
17		If button_b.is_pressed():
18			a = a + 50
Aquest bucle if s�ha d�escriure dins el buecle while, i el que fa es augmentar el valor de la variable a i per tant s�ampliar� el temps entre batecs, reduint-se la freq��ncia.
Si testem ara el projecte veurem que podem incrementar la veMicro:bite batec fins a un m�xim per� que per contre, no hi ha un l�mit per reduir la velocitat de batec.Micro:bit
Modificant la condici� del bucle while
Per introduir una nova condici� per que s�executi el bucle while, crearem una nova variable anomenada lives. Aquesta variable la crearem de tipus boole�.Micro:bitMicro:bitMicro:bit
8	lives = True
Les variable de tipus boole� s�n unes variables que nom�s poden agafar dos valors: cert (True) o fals (False).
Amb aquesta nova variable definida, fem la seg�ent modificaci� al bucle while:
11	while lives:
Si testem ara el codi veur�em que el cor bategaria constantment. Aix� es deu a que no em vinculat el valor de la variabMicro:bitalor de la variable lives, i per tant la condici� �s certa sempre.
Per vincular aquestes variables introduirem un nou bucle if a dins del bucle while. A la l�nia 24 escriurem:
24		If a < 598.80 or a > 1000:
25			lives = false
Aquest bucle if �s una mica diferent als que hem utilitMicro:bitnterioritat. En ell s�est� dient que si el valor de la variable a �s inferior (<) a 598.80 o (or) �s superior a 1000 el valor de la variable lives ser� False.
Si ara testem el codi del projecte, veurem que el cor de la Micro:bit deixa de bategar si accelerem molt el seu batec o si el disminu�m. Ja podem dir que hem simulat el batec de un cor hum� a una Micro:bit, per� anem a fer una darrera millora al codi del nostre projecte.
Darreres modificacions
Emprant la mateixa l�gica que hem utilitzat al darrer bucle if que hem vist, anem a modificar els bucles if que controlen la modificaci� de la variable a, de manera que es pugui incrementar o disminuir el seu valor prement els botons de la Micro:bit o realitzant un altre gest. En aquest cas s�ha triat que al sacsejar la Micro:bit s�incrementar� la velocitat de batec i al acaronar el logotip de la Micro:bit es redueix la velocitat de batec.
Per tant, la l�nia 18 quedar� de la seg�ent forma:
18		if button_a.is_pressed() or accelerometer.was_gesture(�shake�):
i la l�nia 21:
21		if button_b.is_pressed() or pin_logo.is_touched():
Ara, podem comprovar que al realitzar qualsevol dels 4 gestos descrits es modifica la velocitat de batec del cor de la Micro:bit.
Comentaris
Com s�ha vist, un atac al cor no implica que un cor acceleri molt el seu batec o el disminueixi. L�atac no implica que la freq��ncia card�aca augmenti o disminueixi de forma considerable, o perceptible. Aix� que si es vol fer el joc m�s divertit, es poden modificar els l�mits de la variable a i establir-ho a 100 i 1500 per veure com estem augmentant i disminuint el batec al realitzar els diferents gestos.
El codi
Es pot consultar el codi sencer a l�apartat El cor de la Micro:bit de l�ap�ndix.
Ap�ndix

Ap�ndix

El m�s r�pid
1 # Imports
2 from microbit import *
3 import music
4
5 # Main loop
6 while True:
7	if button_a.is_pressed():
8		display.shoe(Image.ARROW_W))
9		music.play(�a�)
10	if button_b.is_pressed():
11		display.shoe(Image.ARROW_E))
12		music.play(�b�)

Pedra, Paper, Tisora
1 # Imports
2 from microbit import *
3 import random
4 import speech
5 import music
6
7 # Main loop
8 while True:
9		if accelerometer.was_gesture('shake'):
10		tool = random.randint(0,2)
11		if tool == 0:
12			display.show(Image.SQUARE_SMALL)
13			speech.say('Pedra')
14			music.play(music.RINGTONE)
15		elif tool == 1:
16			display.show(Image.SQUARE)
17			speech.say('Paper')
18			music.play(music.JUMP_DOWN)
19		else:
20			display.show(Image.SCISSORS);
21			speech.say('Tisores')
22			music.play(music.JUMP_UP)

Codi Morse
1 # Imports
2 from microbit import *
3 import music
4
5 # Main loop
6 while True:
7	if button_a.is_pressed():
8		display.show(Image(�00000:�
9					�00000:�
10					�00900:�
11					�00000:�
12					�00000:�
13					))
14		music.play(�a�)
15	if button_b.Micro:bitd():
16		display.show(Image(�00000:�
17					�00000:�
18					�09990:�
19					�00000:�
20					�00000:�
21					))
22		music.play(�b�)
23	sleep(1000)
24	display.clear()


El batec de la Micro:bit
1 # Imports
2 form microbit import *
3 import music
4
5 # Main loop
6 while True:
7	display.show(Image.HEART)
8	music.play(�a�)
9	sleep(500)
10	display.show(Image.HEART_SMALL)
11	sleep(500)


Conta enrere
1 # Imports
2 from microbit import *
3 imort music
4
5 # Variables
6 i = 10
7
8 # Main loop
9 for index in range(11):
10	display.show(j)
11	music.play(�a�)
12	i = i � 1
13	sleep(1000)


El foraster m�s r�pid
1 # Imports
2 from microbit import *
3 import music
4 import speech
5
6 # Variables
7 game = True
8 turns=5
9 player_a=0
10 player_b=0
11
12 # Functions
13 def countdown(i):
14 	while i>0:
15		for n in range(3):
16			display.show(i)
17			music.play('a')
18			sleep(500)
19			i=i-1
20
21		if i==0:
22			display.show(0)
23
24 def btn_pressed(btn):
25	if btn == 0:
26		display.show(Image.ARROW_W)
27		music.play('a')
28
29	elif btn == 1:
30		display.show(Image.ARROW_E)
31		music.play('b')
32
33	sleep(1000)
34	display.clear()
35	music.play(music.JUMP_DOWN)
35
37 def on_shake(i):
38	if accelerometer.is_gesture('shake'):
39		if i > 0:
49			countdown(i)
41			music.play(music.JUMP_UP)
42			i = 0
43
44 # Main loop
45 while game:
46	on_shake(3)
47
48	if button_a.is_pressed():
49		btn_pressed(0)
50		turns = turns - 1
51		player_a = player_a + 1
52		on_shake(3)
53
54	if button_b.is_pressed():
55		btn_pressed(1)
56		turns = turns - 1
57		player_b = player_b + 1
58		on_shake(3)
59
60	if turns == 0:
61		game = False
62
63		if player_a > player_b:
64			display.show('A')
65			speech.say('Jugador A gana')
66		elif player_b > player_a:
67			display.show('B')
68			speech.say('Jugador B gana')


Un contra l�altre
1 # Imports
2 from microbit import *
3 import random
4 import speech
5 import music
6 import radio
7
8 # Variables
9 turn = True
10 tool = 10
11
12 # Functions
13 def Trie(tool):
14	if tool == 0:
15		display.show(Image.SQUARE_SMALL)
16		speech.say('Pedra')
17	elif tool == 1:
18		display.show(Image.SQUARE)
19		speech.say('Paper')
20	else:
21		display.show(Image.SCISSORS);
22		speech.say('Tisores')
23
24 def Comparison(tool, recieved):
25	result = ''
26
27	if tool == 0:
28		if recieved == "1":
29			result = 'Perds'
30		elif recieved == "2":
31			result = 'Guanyes'
32	elif tool == 1:
33		if recieved == "0":
34			result = 'Guanyes'
35		elif recieved == "2":
36			result = 'Perds'
37	elif tool == 2:
38		if recieved == "0":
39			result = 'Perds'
40		elif recieved == "1":
41			result = 'Guanyes'
42
43	return result
44
45 def Winner(result):
46	if result == 'Guanyes':
47		display.show(Image.SMILE)
48		music.play(music.PYTHON)
49		speech.say('Guanyes')
50	elif result == 'Perds':
51		display.show(Image.SAD)
52		music.play(music.FUNERAL)
53		speech.say('Perds')
54	elif result == 'Empatas':
55		display.show(Image.ASLEEP)
56		music.play(music.WAWAWAWAA)
57		speech.say('Empat')
58
59 def Clean(tool, turn, result):
60	tool = 10
51	turn = True
62	result = ''
63
64 # Main loop
65 while True:
66
67	radio.config(group=12)
68
69	if accelerometer.was_gesture('shake') & turn:
70		turn = False
71		tool = random.randint(0,2)
72
73		Trie(tool)
74
75		sleep(500)
76
77	if pin_logo.is_touched():
78		radio.send(str(tool))
79		recieved=radio.receive()
80
81		result = Comparison(tool, recieved)
82
83		Winner(result)
84
85		sleep(2000)
86
87		Clean(tool, turn, result) 

Missatge Secret
1 # Imports
2 from microbit import *
3 import music
4 import speech
5
6 # Constants
7 ALPHABET = {
    ".-":"A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K", ".-..":"L", "--":"M", "-.":"N", "--.--":"�", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z",
9 }
10
11 # More conversions (not used in the project)
12 # "-----":"0", ".----":"1", "..---":"2", "...--":"3", "....-":"4", ".....":"5", "-....":"6", "--...":"7", "---..":"8", "----.":"9", ".-.-.-":".", "--..--":",", "---...":":", "..--..":"?", ".----.":"'", "-....-":"-", "-..-.":"/", ".-..-.":"\"", ".--.-.":"@", "-...-":"=", "?.?.??":"!"
13
14 # Variables
15 letter = ''
16 word = ''
17
18 # Main loop
19 while True:
20	if button_a.is_pressed():
21		display.show(Image('00000:'
22				'00000:'
23				'00900:'
24				'00000:'
25				'00000'
26				))
27
28		music.play('a')
29		letter = letter + '.'
30
31	if button_b.is_pressed():
32		display.show(Image('00000:'
33				'00000:'
34				'09990:'
35				'00000:'
36				'00000'
37			))
38
39		music.play('b')
40		letter = letter + '-'
41
42	if accelerometer.was_gesture('left') | accelerometer.was_gesture('right'):
43		if letter in ALPHABET:
44			word = word + ALPHABET[letter]
45			music.play(music.POWER_UP)
46			letter = ''Micro:bit
47		else:
48			music.play(music.POWER_DOWN)
49
50	sleep(1000)
51	display.clear()
52
53	if accelerometer.was_gesture('shake'):
54		display.show(word)
55		speech.say((word))


Atac de cor a la Micro:bit
1 # Imports go at the top
2 from microbit import *
3 import music
4
5 # Variables
6 a = 500
7 b = 100
8
9 # Code in a while a > 50 or a < 1000 executes if a value is between 50 and 1000
10 while a > 50:
11	display.show(Image.HEART)
12	music.play('c')
13	sleep(a)
14	display.show(Image.HEART_SMALL)
15	sleep(a)
16
17	if button_a.is_pressed():
18		a = a - 50
19
20 b = 200
21 music.pitch(b)
22 display.show(Image.SKULL)


El pistoler m�s r�pid
1 # Imports
2 from microbit import *
3 import music
4 import speech
5 import radio
6
7 # Variables 
8 rounds = 0
9 score = 0
10 msg = True
11 press = False
12 winner = False
13
14 # Funtions
15 def countdown(i):
16	while i > 0:
17		for n in range(4): 
18			display.show(i)
19			music.play('d') 
20			sleep(1000)
21			i = i - 1
22
23		if i == 0:
24			display.show(0)
25
26 def on_shake(i, press):
27	if accelerometer.is_gesture('shake'):
28		players_pairing()
29
30		if i > 0:
31			countdown(i)
32			music.play(music.JUMP_UP)
33			i = 0
34			press = True
35
36	return press
37
38 def players_pairing():
39	radio.on()
40	radio.config(group=4)
41
42 # Main loop
43 while msg:
44	press = on_shake(3, press)
45
46	if (button_a.is_pressed() | button_b.is_pressed()) & press:
47		radio.send('0')
48		press = False
49		msg = False
50		winner = True
51		music.play('b')
52
53	if radio.receive():
54		msg = False
55
56		if press:
57			display.show(Image.ANGRY)
58			music.play(music.POWER_DOWN)
59
60	if winner:
61		score = score + 1
62		display.show(Image.HAPPY)
63		music.play(music.POWER_UP)
64
65	if pin_logo.is_touched():
66		rounds = rounds + 1
67
68		if rounds < 5:
69			msg = True
70		else:
71			if score >= 3:
72				speech.say('Guanyes')
73				display.show(Image.FABULOUS)
74				music.play(music.PYTHON)
75			else:
76				speech.say('Perds')
77				display.show(Image.SKULL)
78				music.play(music.FUNERAL)


Tria tu
1 # Imports
2 from microbit import *
3 import random
4 import speech
5 import music
6 import radio
7
8 # Variables
9 turn = True
10 tool = 10
11 count = 0
12 points = 0
13
14 # Functions
15 def Trie(tool):
16	if tool == 0:
17		display.show(Image.SQUARE_SMALL)
18		speech.say('Pedra')
19	elif tool == 1:
20		display.show(Image.SQUARE)
21		speech.say('Paper')
22	else:
23		display.show(Image.SCISSORS);
24		speech.say('Tisores')
25
26 def Comparison(tool, recieved):
27	result = ''
28
29	if tool == 0:
30		if recieved == "1":
31			result = 'Pierdes'
32		elif recieved == "2":
33			result = 'Ganas'
34	elif tool == 1:
35		if recieved == "0":
36			result = 'Ganas'
37		elif recieved == "2":
38			result = 'Pierdes'
39	elif tool == 2:
40		if recieved == "0":
41			result = 'Pierdes'
42		elif recieved == "1":
43			result = 'Ganas'
44
45	return result
46
47 def Winner(result):
48	if result == 'Ganas':
49		display.show(Image.SMILE)
50		music.play(music.POWER_UP)
51		speech.say('Ganas')
52	elif result == 'Pierdes':
53		display.show(Image.SAD)
54		music.play(music.POWER_DOWN)
55		speech.say('Pierdes')
56	elif result == 'Empatas':
57		display.show(Image.ASLEEP)
58		music.play(music.WAWAWAWAA)
59		speech.say('Empate')
60
61 def Clean(tool, turn, result):
62	tool = 10
63	turn = True
64	result = ''
65
66 # Main loop
67 while True:
68
69	radio.config(group=12)
70
71	if button_a.was_pressed() & turn:
72		turn = False
73		tool = 0
74
75		Trie(tool)
76
77	elif button_b.was_pressed() & turn:
78		turn = False
79		tool = 1
80
81	elif pin_logo.is_touched() & turn:
82		turn = False
83		tool = 3
84
85	Trie(tool)
86	sleep(500)
87
88	if accelerometer.was_gesture('shake'):
89		radio.send(str(tool))
90		recieved=radio.receive()
91
92		if recieved:
93			result = Comparison(tool, recieved)
94
95			if result == 'Ganas':
96			points = points + 1
97
98			Winner(result)
99
100			if result != 'Empatas':
101				count = count + 1
102
103			sleep(2000)
104
105			if count < 5:
106				count = count + 1
107				Clean(tool, turn, result)
108
109			elif count > 5:
110				if points > 2:
111					display.show(Image.HAPPY)
112					speech.say('Ganas')
113					music.play(music.PYTHON)
114				elif points < 3:
115					display.show(Image.SKULL)
116					speech.say('Pierdes')
117					music.play(music.FUNERAL)

Enviant un missatge
1 # Imports
2 from microbit import *
3 import music
4 import speech
5 import radio
6
7 # Constants
8 ALPHABET = {
9 ".-":"A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K", ".-..":"L", "--":"M", "-.":"N", "--.--":"�", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z",
}
10
11 # More conversions (not used in the project)
12 # "-----":"0", ".----":"1", "..---":"2", "...--":"3", "....-":"4", ".....":"5", "-....":"6", "--...":"7", "---..":"8", "----.":"9", ".-.-.-":".", "--..--":",", "---...":":", "..--..":"?", ".----.":"'", "-....-":"-", "-..-.":"/", ".-..-.":"\"", ".--.-.":"@", "-...-":"=", "?.?.??":"!"
13
14 # Variables
15 letter = ''
16 word = ''
17
18 # Main loop
19 while True:
20	if button_a.is_pressed():
21		display.show(Image('00000:'
22			'00000:'
23			'00900:'
24			'00000:'
25			'00000'
26			))
27
28		music.play('a')
29		letter = letter + '.'
30
31	if button_b.is_pressed():
32		display.show(Image('00000:'
33			'00000:'
34			'09990:'
35			'00000:'
36			'00000'
37			))
38
39		music.play('b')
40		letter = letter + '-'
41
42	if accelerometer.was_gesture('left') | accelerometer.was_gesture('right'):
43		if letter in ALPHABET:
44			word = word + ALPHABET[letter]
45			music.play(music.POWER_UP)
46			letter = ''
47		else:
48			music.play(music.POWER_DOWN)
49
50	sleep(1000)
51	display.clMicro:bit
52
53	if accelerometer.was_gesture('shake'):
54		radio.send(word)
55
56	if radio.receive():
57		msg = radio.receive()
58
59		if msg:
60			display.scroll(msg)
61			speech.say(msg)

El cor de la Micro:bit
1 # Imports go at the top
2 from microbit import *
3 import music
4
5 # Variables
6 a = 769.23
7 b = 75
8 lives = True
9
10 # Main loop
11 while lives:
12	display.show(Image.HEART)
13	music.pitch(b)
14	sleep(a)
15	display.show(Image.HEART_SMALL)
16	sleep(a)
17
18	if button_a.is_pressed() or accelerometer.was_gesture('shake'):
19		a = a - 50
20
21	if button_b.is_pressed() or pin_logo.is_touched():
22		a = a + 50
23
24	if a < 100 or a > 1500:
25		lives = False
26
27 b = 200
28 music.pitch(b)
29 display.show(Image.SKULL)
