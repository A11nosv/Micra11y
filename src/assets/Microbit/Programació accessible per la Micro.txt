Índex
Introducció	3
Introducció	3
Parlant de codi accessible	3
Com està organitzat el quadern?	3
Programació Bàsica	4
El més ràpid	5
Pedra, paper, tisora	7
Codi Morse	10
El batec de la Micro:bit	15
Conta enrere	17
Programació Intermèdia	19
El foraster més ràpid	20
Un contra l’altre	27
Missatge secret	33
Atac de cor a la Micro:bit	36
Programació Avançada	38
El pistoler més ràpid	39
Tria tu	43
Enviant un missatge	46
El cor de la Micro:bit	47
El més ràpid	51
Pedra, Paper, Tisora	52
Codi Morse	53
El batec de la Micro:bit	54
Conta enrere	55
El foraster més ràpid	56
Un contra l’altre	58
Missatge Secret	61
Atac de cor a la Micro:bit	63
El pistoler més ràpid	64
Tria tu	67
Enviant un missatge	71
El cor de la Micro:bit	73



Introducció
Introducció
Moltes de les aplicacions que hi ha per fer amb Micro:bit tenen dos greus problemes per usuaris amb discapacitat visual.
1. El codi tendeix a estar en format HEX (blocs).
2. La Micro:bit no sol realitzar cap no emet cap estímul sonor.
A aquest petit quadern es vol mostrar com realitzar programes accessibles per la Micro:bit i com programar de forma accessible per que tots els usuaris puguin crear les modificacions necessàries o personalitzar el codi ja creat.
Parlant de codi accessible
Si es vol crear un codi accessible, és a dir, que tots els usuaris puguin consultar i modificar, a dia d’avui no podem utilitzar la programació per blocs. Per tant la pàgina de MakeCode amb els blocs queda descartada.
A banda dels blocs de programació es poden utilitzar dos llenguatges de programació:
> JavaScript.
> Python.
A aquest manual s’utilitzarà Python per la realització dels programes. Tots els programes es compartiran a MakeCode, i per tant es podrà veure i descarregar el codi en JavaScript i en- Blocs (en alguns cassos).
Per realitzar la programació, en lloc de MakeCode s’utilitzarà l’editor de Python, que permet utilitzar més característiques del llenguatge de programació, algunes de les quals no es poden reproduir a la programació per blocs.
Aquest editor té un problema en front de MakeCode i és que no es pot emmagatzemar a un repositori que s’obri amb la pàgina web. Per tant, tot s’emmagatzemarà a un repositori propi, i també a MakeCode.
Aquest editor és accessible amb els lectors de pantalla, tot i que presenta alguns problemes en el seu ús.
Com està organitzat el quadern?
El quadren està organitzat en tres seccions bàsiques:
1. Programació Bàsica.
2. Programació Intermèdia.
3. Programació Avançada.
Al nivell principiant s’explicarà línia a línia el que fa el codi, al menys als primers exemples. Aquesta explicació serà menor al nivell interni, on només s’explicaran el per que d’algunes línies. A mesura del possible, els projectes Intermedis seran ampliacions del codi d’un projecte que s’ha iniciat a la Programació Bàsica.
A l’annex del document s’inclou una petita fitxa de cada projecte on hi ha un petit resum sobre les característiques i les funcions que s’utilitzen pel seu desenvolupament.
Programació Bàsica


El més ràpid
Introducció
Ets el més ràpid a aquesta banda del Llobregat? Anem a veure-ho! Prepara els teus dits per veure qui desenfunda més ràpid
Objectiu
Aquest primer projecte amb Python per Micro:bit és un senzill codi que ens permetrà crear un joc per a dos jugador amb una única Micro:bit. El joc consisteix en veure qui pitja de forma més ràpida el botó de la Micro:bit. Un temporitzador valorarà si el jugador A ha pitjar el botó A abans que el jugador B pitgi el botó B de la Micro:bit.
Llestos. A les seves marques. Ja!
Primers passos
Per crear el nostre projecte començarem, com sempre, important els mòduls necessaris, que en aquest cas serà només el de Micro:bit.
1	from microbit import *
Un cop importat el mòdul començarem el bucle de l’aplicació amb un bucle while de la següent manera:
5	while True
Els bucles while s’executen sempre que la condició sigui certa. D’aquest forma, si creem un bucle while True, estem creant un bucle infinit ja que la condició d’inicialització del bucle sempre serà certa.
Un cop creat el bucle que controlarà l’execució del projecte, hem de crear dos bucles if. Un pel botó A i un altre pel botó B. El bucle pel botó serà:
6		if button_a_is.pressed():
7			display.show(Image.ARROW.W)
Segons aquest bucle, quan es pitgi el botó A apareixerà en pantalla un fletxa indicant que el botó A ha sigut el primer en ser pitjat.
Pel botó B farem el mateix bucle modificant que el botó a pitjat és el B i el sentit de la fletxa. El bucle serà de la forma:
9		if button_b_is.pressed():
10			display.show(Image.ARROW.E)
Si executem ara el codi del projecte veurem que apareix una fletxa indicant quin botó ha sigut el que s’ha pitjat abans, i per tant, al guanyador. Però aquest codi té una gran mancança ara mateix, i és que la indicació és només visual. Anem a incorporar una senyal sonora de forma que emeti un so diferent quan es pitja el botó A o el botó B.
Incorporant sons
Per incorporar un so primer haurem d’importar un nou mòdul, D’aquesta manera, a sota de l’import del mòdul de Micro:bit escriurem:
3	 import music
Al importar aquest mòdul, ara podrem fer que la Micro:bit emeto diferents sons. Per que emeti un so al pitjar el botó A, escriurem, dins del bucle del botó A la següent línia:
9	music.play(‘a’)
A dins del bucle pel botó B escriurem el mateix però en lloc d’a escriurem b de la següent manera:
13	music.play(‘b’)
Ara de forma sonora s’està indicant qui ha sigut el primer en pitjar un botó.
El joc ha millorat força. Tot i això continua havent-hi un petit problema. Quin?
Que un dels jugadors, o els dos jugadors, ha de realitzar una conta enrere per que comenci el joc. Però podem fer que això ho faci la Micro:bit per nosaltres, com veurem més endavant a El foraster més ràpid.
Codi
El codi sencer d’aquest projecte es pot consultar a la secció El més ràpid de l’Apèndix.


Pedra, paper, tisora
Introducció
Qui més qui menys al llarg de la seva infantesa ha jugat al joc de pedra, paper, tisora. A aquest projecte volem anar una mica més enllà i jugar al joc amb dues Micro:bit.
Per realitzar aquest projecte haurem d’utilitzar els mòduls speech i random de la Micro:bit. La designació del que traurà la Micro:bit per pantalla es farà de forma aleatòria al sacsejar la Micro:bit.
Se que tens moltes ganes de començar a jugar. Així doncs: COMENCEM!
Important els mòduls
Com sempre, el primer que farem serà importar els mòduls necessaris per la realització del projecte. Per aquest projecte necessitarem els següents mòduls;
* microbit.
* random.
* speech.
Així doncs, el nostre programa en Python ha de començar de la següent manera:
1 # Imports
2 from microbit import *
3 import random
4 import speech
Bucle principal
Un cop tenim els imports declarats, crearem el bucle inicial, que com sempre, a aquesta secció de Programació Bàsica és un del tipus while True. Recordem que aquest és un bucle infinit i que per tant, sempre s’està executant a la Micro:bit.
El bucle tindrà la següent forma:
6 # Main Loop
7 while True:
8		if accelerometer.was_gesture('shake'):
9			tool = random.randint(0,2)
10		if tool == 0:
11			display.show(Image.SQUARE_SMALL)
12		elif tool == 1:
13			display.show(Image.SQUARE)
14		else:
15			display.show(Image.SCISSORS);
Explicació del codi
El codi es compon bàsicament d’una sèrie de bucles if niats entre ells que realitzen una acció una altre depenen del valor de la variable tool. La variable tool és una variable de tipus integer (enter) que agafa nombres aleatoris entre 0 i 2 quan es sacseja la Micro:bit. Per obtenir aquesta variable s’utilitza el mètode randint(a,b) del mòdul random de la següent manera:
tool = random.randint(a,b)
on:
* a: és el valor mínim que pot agafar la variable tool.
* B: és el valor màxim que pot agafar la variable tool.
Un cop s’ha calculat el valor de la variable simplement fem que es mostri una figura o una altre a pantalla depenent del seu valor mitjançant un bucle if.
Fent el joc més accessible
Si executem el codi, veurem que es por jugar sense cap tipus de problema, aparentment. El joc té un problema i és que tal i com està creat només poden jugar aquelles persones que no tenen una discapacitat visual, i que per tant poden veure el gràfic de la pantalla de la Micro:bit.
La forma de fer que aquest projecte sigui accessible a les persones a discapacitat visual és afegint-hi un so. En aquest cas afegirem una veu, la veu de la Micro:bit dirà que hem tret a la nostra tirada.
Com ja tenim el mòdul speech importat, només ens calen afegir tres línies, una a cada bucle if. Aquestes línies són:
12 speech.say('Pedra')
15 speech.say('Paper')
18 speech.say('Tisora')
Al afegir aquestes línies, fem que la Micro:bit informe el valor de la tirada de cada jugador. Si executem el codi veurem que la veu de la Micro:bit no és molt agradable i que és angles. Això pot dificultar una mica la comprensió del resultat de cada jugador. Per aquest motiu podríem incloure un so diferent per cada resultat.
Afegint un so
Per afegir un so hem d’importar el mòdul de música. Al bloc dels imports afegirem la següent línia:
5 import music
Ara ja podem reproduir un so diferent per cada tirada. El so el reproduirem desprès de que parli la Micro:bit. Per fer-ho afegirem les següents línies:
14 music.play(music.RINGTONE)
18 music.play(music.JUMP_DOWN)
22 music.play(music.JUMP_UP)
Ara desprès de dir el que s’ha tret a la tirada s’emetrà un so diferent.
El codi
El codi sencer del projecte es pot consultar a la secció XXX de l’apèndix.


Codi Morse
Introducció
El codi o alfabet Morse va ser creat per Samuel Morse i es basa en la representació de lletres i números mitjançant senyals emeses de forma intermitent.
D’aquesta forma, la lletra A es pot transmetre mitjançant un punt i un guió, tal i com es pot veure a la Imatge 1.

Imatge 1 Alfabet Morse.
Objectiu
A aquest projecte farem que la Micro:bit escrigui a pantalla el codi Morse i emeti un so diferent quan pitgem el botó A (punt) o el botó B (guió).
Primers passos
Per crear el nostre projecte començarem, com sempre, important els mòduls necessaris, que de moment serà el de Micro:bit. Per tant a la primera línia escriurem:
1	from microbit import *
Un cop escrita aquesta línia. Començarem amb el bucle principal del projecte. Aquest bucle serà un bucle de tipus while. Els bucle de tipus while s’executen sempre, de manera contínua quan la condició sigui certa, Per fer que un bucle com aquest s’executi indefinidament hem d’assignar-li una condició True (cert).
La segona línia de codi serà de la forma:
5	while True:
El següent pas serà assignar una acció als botons A i B de la Micro:bit. Per això utilitzarem un altre tipus de bucle, el bucle if. Es podria dir que els bucles if són bucles de preses de decisions, una cruïlla a un camí. Aquest bucle, com el while, només s’executa si la condició és certa; en cas que la condició no sigui certa, llavors s’agafa l’altre camí, i a diferència dels bucles while, els bucles if només s’executen un vegada, si la condició és certa, o cap, en cas de que la condició sigui falsa.
Així doncs, la següent línia del nostre codi serà:
6		if button_a.is_pressed():
El següent pas es escriure el codi que s’executarà en cas de que pitgem el botó A. Si pitgem el botó A de la Micro:bit, volem que es mostri a la pantalla un punt. Per fer-ho escriurem:
7			display.show(Image(‘00000:’
8						‘00000:’
9						‘00900:’
10					‘00000:’
11					‘00000’))
El valor 0 indica que el led de la Micro:bit situat a la posició tindrà una intensitat 0, o el que és el mateix, no s’il·luminarà. Per contra, el valor 9 indica que el led situat a aquella posició tindrà una intensitat màxima.
Al poder assignar diferents intensitats les leds de la pantalla de la Micro:bit, podem realitzar animacions millors i jugar a fer ombres o animacions millors.
Per últim, copiarem el bucle if que acabem de crear i substituirem la lletra a per la lletra b a la condició del codi i a la files on hem escrit ‘00900:’ escriurem ‘09990:’ per dibuixar una línia a la pantalla.
El codi hauria de ser una cosa semblant al següent:
1	# Imports
2	from microbit import *
3	import music
4
5	# Main loop
6	while True:
7		if button_a.is_pressed():
8			display.show(Image('00000:'
9					'00000:'
10					'00900:'
11					'00000:'
12					'00000'
13			))
14
15		if button_b.is_pressed():
16			display.show(Image('00000:'
17					'00000:'
18					'09990:'
19					'00000:'
20					'00000'
21		))
Si ara executem el codi al simulador de la Micro:bit, veurem que quan es pitjar el bitó A apareix un punt al centre de la pantalla, i quan pitgem el B apareix una línia de 3 punts. Hem aconseguit escriure els dos signes generadors del codi mors!
Afegint estímuls
Anem pel bon camí, però al primer capítol hem dit que es busquen projectes que estimulin més d’un sentit, i ara mateix només estem estimulant el sentit de la vista. Anem a estimular el sentit de l’oïda.
Per fer-ho, farem que la Micro:bit emeti un so durant un instant quan pitgem el botó A i el mateix s, el doble de temps, quan pitgem el botó B. El primer de tot, serà importar el mòdul music. Per fer-ho escriurem a sota de l’altre import:
3	import music
Ara que hem importat el mòdul, podem començar a utilitzar els seus mètodes. Per emetre una nota escriurem, dins del primer bucle if:
15		music.play(‘a’)
El següent pas serà copiar la línia anterior dins l’altre bucle if modificant a per b per produir una nota diferent i permetre a l’oïda diferenciar entre un punt i un guió.
El codi, amb les modificacions hauria de tenir una forma similar al següent:
1	# Imports
2	from microbit import *
3	import music
4
5	# Main loop
6	while True:
7		if button_a.is_pressed():
8			display.show(Image('00000:'
9					'00000:'
10					'00900:'
11					'00000:'
12					'00000'
13						))
14
15			music.play('a')
16
17		 if button_b.is_pressed():
18			display.show(Image('00000:'
19					'00000:'
20					'09990:'
21					'00000:'
22					'00000'
23						))
24
25			music.play('b')
Si executem el codi al simulador, veurem que al pitjar el botons es mostra a pantalla un dels símbols generadors i s’emet un so diferent. Pràcticament ho tenim enllestit. Hi ha un petit però.
El però és que el punt i el guio resten a pantalla tota l’estona fins que es pitja un altre cop un dels botons, quan hauria d’estar només un temps limitat.
Netejant la pantalla.
Per netejar la pantalla hem d’incloure, just al final dels dos bucles if, o al final del bucle while, les següents línies:
26		sleep(500)
27		display.clear()
En el meu cas les he afegit al final del bucle while.
A l’apartat Enviant missatges desenvoluparem aquest codi per enviar un missatge als nostres amics.
Codi
El codi sencer d’aquest projecte es pot consultar a la secció Codi Morse de l’Apèndix.


El batec de la Micro:bit
A molts quaderns de programació de Micro:bit el primer programa a realitzar és la animació del bateig d’un cor. Aquesta activitat té un problema des del punt de vista de l’accessibilitat. El problema és que només hi ha un estímul visual, i per tant, les persones amb una discapacitat visual no poden gaudir plenament l’experiència.
A aquesta activitat, a banda de mostrar un cor bategant a la pantalla de la Micro:bit, s’emetrà un so de bateig, creant d’aquesta forma un estímul sonor que permetrà als discapacitats visuals gaudir més de l’experiència.
Comencem a programar!
El Codi
El codi bàsic d’aquest projecte és el següent:
1	# Imports go at the top
2	from microbit import *
3
4	# Code in a 'while True:' loop repeats forever
5	while True:
6		display.show(Image.HEART)
7		sleep(500)
8		display.show(Image.HEART_SMALL)
9		sleep(500)
Emetent batecs
Modificarem aquest codi per que la Micro:bit també emeti un so amb les animacions del cor bategant. Per això escriurem la següent línia:
3	import music
Aquesta línia la inserirem a sota de la línia de la importació inicial, és a dir, serà la línia 3 del nostre codi.
Ara només hem d’afegir una línia a sota de la línia de codi on es mostra el cor gran. La línia que hem d’afegir és:
music.play(‘a’)
La línia s’inserirà a la posició 8 del codi. Amb tot el codi del projecte quedarà de la següent forma:
1	# Imports go at the top
2	from microbit import *
3	import music
4
5	# Code in a 'while True:' loop repeats forever
6	while True:
7		display.show(Image.HEART)
8		music.play(‘a’)
9		sleep(500)
10		display.show(Image.HEART_SMALL)
11		sleep(500)
Explicació del codi
Ara que hem vist quina pinta té el codi, anem a explicar que fa cada línia:
1. A les línies 1 i 5 introduïm comentaris per explicar que estem fent a les línies següents. A Python els comentaris van precedit del símbol #. Tot el que hi hagi escrit a una línia darrere d’aquest símbol no serà compilat i es considerarà un comentari.
      Nota: Els comentaris en programació es realitzen en anglès.
2. A les línies 2 i 3 importem les llibreries necessàries per que es pugui compilar el codi que estem escrivint. En aquest cas hem importat dues llibreries:
a. Micro:bit. Per poder utilitzar les llibreries pròpies de Micro:bit.
b. Music. Per poder emetre sons mitjançant la Micro:bit.
3. A la línia 6 s’inicia un bucle while. Aquest bucle finalitza a la línia 11. Els bucles while serveix per executar de forma contínua una part de codi sempre que la condició que els executa sigui certa. En aquest cas hem dit while True. Aquesta condició serà sempre certa i per tant, hem creat un bucle infinit que s’executarà de forma contínua.
4. A les línies 7 i 10 es crida al classe display que conté el mètode show(). A aquest mètode serveix per mostrar una imatge a la pantalla de la Micro:bit, En aquest exemple es passa la imatge d’un cor gran (a la línia 7) i un cor petit a la línia 10.
5. A la línia 8 es crida a la classe music per utilitzar el mètode play(). A aquest mètode se li ha de passar un nombre sencer. En aquest cas li passem el valor 100. Això fa que la Micro:bit emeti una nota a una freqüència de 100Hz.
6. A les línia 9 i 11 s’imposa un temps d’espera de 500 mil·lisegons. Aquest temps d’espera entre imatge i imatge és el que crea l’animació de batec, al passar contínuament d’un cor gran a un petit i d’un cor petit a un gran.
Codi
El codi sencer es pot consultar a la secció El batec de la Micro:bit de l’apèndix.


Conta enrere
Aquest projecte és la programació d’una conta enrere des de 10 fins a 0. La conta enrere es mostrarà a la pantalla de la Micro:bit i anirà acompanyada d’una pulsació, la mateixa que es va fer al projecte El batec de la Micro:bit, per tenir una estimulació sonora a banda d’una visual.
Al projecte es veurà un nou tipus de bucle, un bucle for i es veurà com declarar una variable que utilitzarem per realitzar la conta enrere.
Comencem el conta enrere!
Declarant una variable
El codi de la conta enrera, és possiblement, més senzill que el codi del projecte anterior, encara que també té les seves peculiaritats. La primera és la declaració d’una variable.
Quan parlem de variables, hem de saber distingir entre una variable d’àmbit global i una d’àmbit local. De moment, l’únic que cal saber és que les variables d’àmbit global, com la que utilitzarem a aquest projecte, és declaren just desprès de la línia dels imports i es fa de la següent manera:
[nom variable] = [valor variable]
Un exemple de declaració seria:
i = 10
Dit això, just a l’inici del nostre projecte escriurem:
1	# Imports go at the top
2	from microbit import *
3	import music
4
5	# Variables
6	i = 10
A la línia 6 realitzem la declaració de la variable i i el seu valor: 10.
Bucle for
Desprès de la declaració de la variable iniciem el bucle for, que és el bucle principal del projecte.
8	# Main loop
9	for index in range(11):
10	display.show(i)
11	music.play(‘a’)
12	i = i - 1
13	sleep(1000)
Explicació del codi
A aquest projecte hem d’explicar el bucle for. Un bucle for s’executa un determinat nombre de cops. Per decidir quants cops s’executa una bucle for es tendeix a incloure un algoritme que modifica el valor de la variable que controla el bucle cada cop que s’executa el bucle. En aquest cas es modifica el valor de la variable i.
A la línia 9 declarem el bucle for i establim que s’executarà 11 cops (index in range(11)). Expliquem una mica més aquesta darrera sentència:
* index: Es el valor que s’anirà modificant.
* in; vincular index amb el seu rang de valors.
* range(): Indica el rang de valors, o els passos a realitzar pel bucle.
* 11: És el nombre de cops (passos) que s’executarà el bucle for.
Les línies 10 i 11 ja les coneixem del projecte anterior. A la línia 12 el que estem fent és reduir en un valor la variable i cada cop que s’executa el bucle for.
Per últim, a la línia 13 fem que el codi s’aturi 1 segon abans de tornar-se a executar el bucle for.
Concepte
No ha cridat l’atenció alguna cosa del codi? Us heu fixat que el valor de la variable i és de 10 i executem el bucle for 11 cops? Aquesta “incoherència” es deu a que el 0 és un nombre i per tant s’ha de tenir en compte alhora de programar. Si fem que el bucle for s’executi només 10 cops el darrer nombre que assolirà la variable i serà 1 i no 0.
Feu la prova!
Codi
El codi sencer d’aquest projecte es pot consultar a la secció  de l’Apèndix.


Programació Intermèdia


El foraster més ràpid
Introducció
A aquest projecte farem una combinació de dos projectes vists a la secció de programació inicial. Els projectes que combinarem són: El més ràpid i Conta enrere. Com veurem caldrà realitzar algunes modificacions al codi que ja vist.
Objectiu
L’objectiu d’aquest projecte és veure com utilitzar bucles dins de bucles (bucles niats). Per fer-ho es mostrarà un exemple amb dos bucles while.
També es veurà el reaprofitament de blocs de codi mitjançant la definició de funcions.
Afegint un compte enrere
El primer que hem de fer és afegir la declaració d’una variable a sota del bloc dels imports, però iniciant la variable a 3. D’aquesta forma escriurem:
5	 # Variables
4	i = 3
El següent pas serà escriure el bucle for dins del bucle while de la següent forma:
7
8	 while True:
9		for index in range(4):
10			display.show(i)
11				music.play(‘a’)
12				i = i - 1
13				sleep(1000)
Si executem el codi del projecte veurem que el compte enrere és infinit, i un cop s’arriba al zero es continua comptant en nombre negatius.
Per que això no succeeixi s’ha de fer segon bucle while niat, és a dir, un bucle while dins un altre bucle while. El codi anterior quedarà de la següent forma:
7
8 while True:
9		while i > 0:
9			for index in range(3):
10				display.show(i)
11				music.play(‘a’)
12				i = i - 1
13				sleep(1000)
14		
15				If i == 0:
16					display.show(0):
17					music.play(music.JUMP_UP)
Al niar un bucle while, estem fent que el bucle for s’executi dins el segon bucle while. Aquest segon bucle while només s’executarà quan el valor d’i sigui superior a menys 1 (–1). En el moment en que el valor de la variable sigui zero (0), es mostrarà el valor en pantalla, s’emetrà un so i es sortirà d’aquest bucle while; continuant-se l’execució del bucle while inicial.
Una cosa que ens em de fixar és que ara el rang de i és tres (3) i no quatre (4) com abans. El rang s’ha disminuït en un valor per evitar una superposició de dos sons al arribar al valor de zero (0). Amb aquesta modificació s’evita que el zero faci el so de a conta enrere.
Si es vol que el zero (0) formi part de la conta enrere, llavors al bucle if, en lloc de mostrar-se el valor de zero (0) es podria mostrar un text que digués JA quan s’emeti el so d’inici del joc.
Ja tenim creada la conta enrere. Si enganxem el codi del projecte a fora del segon bucle while però a dins del primer, ja tindrem el nostre projecte executant-se de forma adient.
El bucle principal del projecte hauria de tenir la següent forma:
9 while True:
10	while i > 0:
11		for n in range(3): 
12			display.show(i)
13			music.pitch(100) 
14			sleep(1000)
15			i = i - 1
16
17			if i == 0:
18				display.show(0)
19				music.play(music.JUMP_UP)
20
21		if button_a.is_pressed():
22			display.show(Image.ARROW_W)
23			music.play('a')
24			sleep(500)
25
26		elif button_b.is_pressed():
27			display.show(Image.ARROW_E)
28			music.play('b')
29			sleep(500)
Si executem ara el codi del nostre projecte ens cridarà l’atenció que al pitjar el botó A o B de la Micro:bit la fletxa es mostra tota l’estona i si es torna a pitjar una altre cop, la fletxa modifica el seu sentit depenent del botó pitjar, és a dir, no es torna a realitzar una conta enrere.
El que es vol és que es torni a iniciar el conta enrere per tornar a jugar. Anem a veure com ho podem fer.
Reiniciant el compte enrere
El primer que hem de fer és redefinir el bucle while intern i convertir-lo en una funció. Les funcions són blocs de codi que es poden utilitzar i que s’han de declarar abans de la seva utilització. Si es declara desprès de la seva utilització el programa ens retornarà un error.
Dit això, declararem la funció abans del primer bucle while de la següent forma:
8 def countdown(i):
9 
10	while i > 0:
11		for n in range(3): 
12			display.show(i)
13			music.play(‘a’)
14			sleep(500)
15			i = i - 1
16
17			if i == 0:
18			display.show(0)
Ara que tenim la funció definida, expliquem-la. Per definir una funció sempre s’utilitzarà la paraula reservada def seguida del nom de la funció. En el cas anterior seria def countdown( ). Desprès dels parèntesis s’han d’escriure dos punts ( : ) que indiquen l’inici de la definició de la funció, de igual manera que es fa amb un bucle while, per exemple.
A dins d’aquesta funció s’ha inserit tot el bucle while que estava niat. Per fer que s’executi la funció la hem de cridar al bucle principal. Per fer-ho escriurem el nom de la funció just a sota de l’inic del bucle while i dins d’un bucle if de la següent manera:
23	if i > 0:
24		countdown(i)
25		music.play(music.JUMP_UP)
26		i = 0
El bucle if és necessari per evitar que la funció countdown( ) sigui cridada infinitament. El mateix passa amb la igualtat i = 0. Sense aquestes dues línies la funció seria cridada una vegada i un altre fent-se un conte enrere des de 3 fins a 0 de forma infinita.
Ara, per saber si s’ha pitjar el botó A o B de la Micro:bit definirem una funció a la que se li passarà un valor de 0, si s’ha pitjat el botó A o un valor 1 si s’ha pitjat el botó B. Degut que a aquesta funció se li passa un paràmetre, entre els parèntesis s’ha d’escriure una variable que agafarà el valor que se li passa a la funció.
La definició de la funció serà de la següent manera:
21	def btn_presed(btn):
22		if btn == 0:
23			display.show(Image.ARROW_W)
24			music.play('a')
25     
26		elif btn == 1:
27			display.show(Image.ARROW_E)
28			music.play('b')
29
30		sleep(1000)
A la variable l’hem anomenat btn, i depenent del valor de btn s’executarà un o altre bloc del bucle if. Ara només ens cal cridar a la funció a dins del bucle while principal. Al cridar la funció haurem de passar el valor que es vol que adquireixi la variable btn. La crida la farem dins d’un bucle if contingut al bucle principal while de la següent manera:
39	if button_a.is_pressed():
40		btn_presed(0)
41	elif button_b.is_pressed():
42		btn_presed(1)
Si estudiem aquest bloc de codi, veiem que quan es pitja el botó A la funció btn_pressed( ) se li passa el valor 0, i si es pitja el botó B se li passa el valor 1. D’aquesta forma, la variable btn agafa un valor o un altre depenent del botó que es pitgi.
Encara hem de realitzar una modificació. Si intentem cridar a les funcions ja creades de forma reiterativa es veurà com el bucle principal s’executa de forma indefinidament. Per evitar això hem de crear una nova funció que s’activi quan els jugadors realitzin una acció sobre la Micro:bit. En aquest cas s’ha triat un sacseig de la mateixa.
La definició de la funció seria:
32	def on_shake(i):
33		if accelerometer.is_gesture('shake'):
34			if i > 0:
35				countdown(i)
36				music.play(music.JUMP_UP)
37				i = 0
A aquesta funció se li passa un valor que és agafat per la variable i. A la funció es crida a la funció countdown( ). Aquesta crida es realitzarà si el valor de la variable i és superior a 0. Un cop la variable assoleix el valor de 0 es produeix el so i es surt de la funció.
Al haver-se creat aquesta nova funció, ara hem de cridar-la des de l’interior del bucle while principal de la següent manera:
40 while True:
41	on_shake(3)
Bucle while principal
Amb totes aquestes modificacions el bucle while principal he de tenir la següent forma:
40	while True:
41		on_shake(3)
42
43		if button_a.is_pressed():
44			btn_presed(0)
45		elif button_b.is_pressed():
46			btn_presed(1)
Tal i com està ara mateix el bucle principal del nostre projecte estem fent que el joc sigui infinit. Per modificar aquest comportament hem de crear una variable nova que anirà sumant o restant valors cada cop que s’executi el bucle. D’aquesta forma podrem fer que el bucle s’executi un nombre determinar de vegades.
Així doncs, definim una variable global:
5 # Variables 
6 game = True
7 turns = 5
I modificar la condició d’execució del bucle while segons el valor de la nova variable:
43	while game:
Ara, per fer que el bucle finalitzi hem de sumar un valor cada cop que executem el bucle sencer. Ara, dins de cada bucle if, al final, escrivim la sentència: turns = turns -1. D’aquesta forma, cada cop que pitgem un dels botons de la Micro:bit es reduirà en 1 el valor de la variable turns.
Això ho farem mitjançant un bucle if.
61	if turns == 0:
62		game == False
Dient el guanyador
El joc ja és funcional i es poden jugar 5 torns, però no hi ha un marcador ni un guanyador. Anem a afegir-ho.
El primer que farem serà importar el mòdul speech per fer que la Micro:bit digui qui ha guanyat. Al bloc dels imports afegirem:
4 import speech
També hem d’afegir dues variables al bloc de les variables.
9 player_a = 0
10 player_b = 0
A aquestes dues variables guardarem el marcador del jugador a (player_a) i el del jugador b (player_b).
Ara, només ens manca incrementar el marcador del jugador més ràpid en cada torn. Per fer-lo a l’interior del bucle if del botó A afegirem:
52		player_a = player_a + 1
I a dins del bucle if del botó B:
58		player_b = player_b + 1
Amb això ja hem aconseguit el nostre marcador. Ara només manca que es mostri al finalitzar la partida.
Per fer-ho modificarem el darrer bucle, on es finalitza la partida, afegint les següents línies:
65	if player_a > player_b:
66		display.show(‘A’)
67		speech.say(‘jugador A gana’)
68	elif player_b > player_a:
69		display.show(‘B’)
70		speech.say(‘jugador B gana’)
D’aquest forma hem finalitzat el joc del pistoler més ràpid. Les partides han estat programades per 5 torn. Si volem jugar més torns només hem d’incrementar el valor de la variable turns.
Codi
El codi sencer del projecte es pot consultar a l’apartat El foraster més ràpid de l’apèndix.

Un contra l’altre
Objectiu
A aquest projecte reprendrem el projecte Pedra, paper, tisora i el retocarem per enviar el resultat d’una Micro:bit a una altre i així saber qui és el guanyador mitjançant un missatge verbal i una música.
Per connectar les dues Micro:bit, com veurem, ens caldrà importar el mòdul de ràdio i fer alguns configuracions, però no ens avancem i anem a a millorar el joc!
Important el mòdul radio
Com sempre que volem utilitzar un mòdul de la Micro:bit que encara no hem utilitzar, hem d’importar-ho al bloc dels import. A aquest bloc afegirem la següent línia:
6 import radio
Un cop importat aquest mòdul, ja el podem utilitzar per connectar les dues Micro:bit.
Creant un grup
Per poder connectar dues o més Micro:bit hem de crear un grup de connexió. La creació d’un grup fa que només les Micro:bit que pertanyin al grup es connectin entre elles, deixant a la resta fora del grup i evitant interferències. D’aquesta forma es poden realitzar partides simultànies si modifiquem el nom del grup.
Els grups s’anomenen amb un número; per tant, utilitzant un símil a radiofònic, es podria dir que modifiquem la freqüència d’emissió i recepció utilitzant diferents canals. Per crear un grup escriurem, just a sota de l’inicia del bucle principal while el següent:
11	radio.config(group=12)
En aquest cas hem assignat el número 12, però es pot assignar qualsevol altre número entre 0 i 255.
Enviant i rebent informació
Ara que hem establint un grup, podem connectar les Micro:bit. Per fer-ho, just desprès del darrer bucle if escriurem:
30	radio.send(str(tool))
31	recieved=radio.receive()
32	result = ''
A la línia 30 estem enviant la variable tool a l’altre Micro:bit; a la 31 estem rebent l’enviament de l’altre Micro:bit i assignant el valor a una nova variable anomenada recieved. A la darrera línia creem una nova variable buida anomenada result que utilitzarem més endavant. Recordem que aquestes noves variables son locals.
El següent pas és la creació de bucles if niats per la pressa de decisions depenent dels valors de les variables tool i recieved.
Pressa de decisions
Per la pressa de decisions niarem diferents bucles if. Al bucle if més extern valorarem la variable tool i a l’interna la variable recieved de la següent manera:
35	if tool == 0:
36		if recieved == "1":
37			result = 'Perds'
38		elif recieved == "2":
39			result = 'Guanyes'
40	elif tool == 1:
41		if recieved == "0":
42			result = 'Guanyes'
43		elif recieved == "2":
44			result = 'Perds'
45	elif tool == 2:
46		if recieved == "0":
47			result = 'Perds'
48		elif recieved == "1":
49			result = 'Guanyes'
En aquest cas no podem utilitzar l’operador lògic & per resoldre la presa de decisions degut a que la variable tool és un integer (enter) i la variable recieved és un string (cadena). Per aquest motiu no es pot realitzar una comparació de variables.
Com veiem al codi anterior, la nova variable result està prenent el valor del resultat de la comparació entre les variables tool i recieved.
Tria del guanyador
Ara amb el valor de la variable result mostrarem a pantalla i amb so qui dels dos jugadors ha guanyat. Per realitzar això utilitzarem un bucle if de la següent manera:
51	if result == 'Guanyes':
52		display.show(Image.SMILE)
53		music.play(music.PYTHON)
54		speech.say('Guanyes')
55	elif result == 'Perds':
56		display.show(Image.SAD)
57		music.play(music.FUNERAL)
58		speech.say('Perds')
59	elif result == 'Empatas':
60		display.show(Image.ASLEEP)
61		music.play(music.WAWAWAWAA)
62		speech.say('Empat')
Amb aquest darrer bucle tindríem un projecte operatiu. Si veiem el codi, aquest és ara mateix una mica confús i brut. Així que anem a netejar-ho.
Netejant el codi
El primer que farem serà esborrar les línies on reproduïm un so quan apareix el resultat a pantalla, és a dir, les línies 18, 22 i 26. Ara ja no cal que s’emeti un so diferent depenent del valor de la tirada. Realment també podríem treure les línies 17, 21 i 25; però les deixarem per que el jugador sàpiga quin és el valor de la seva tirada.
Una altre cosa que es pot realitzar per netejar el codi i fer-ho més entenedor és crear funcions per agrupa diferents blocs de codi. D’aquesta forma crearem una funció anomenada Trie( ) a la que se li passarà la variable tool.
La definició de la funció es realitzarà abans del bucle while de la següent manera:
8 # Functions
9 def Trie(tool):
10	if tool == 0:
11		display.show(Image.SQUARE_SMALL)
12		speech.say('Pedra')
13	elif tool == 1:
14		display.show(Image.SQUARE)
15		speech.say('Paper')
16	else:
17		display.show(Image.SCISSORS);
18		speech.say('Tisores')
Al lloc on estava aquest bloc de codi cridarem a la funció:
28	Tries(tool)
Podem fer el mateix amb els altres dos bucles i crear dues noves funcions, que anomenarem Comparison( ) i Winner( ). A la primera funció realitzarem la comparació de les variable i retornarem el valor de la variable result.
Aquesta primera funció l’escriurem just a sota de la funció Tries(tool) i serà:
20 def Comparison(tool, recieved):
21	result = ''
22
23	if tool == 0:
24		if recieved == "1":
25			result = 'Perds'
26		elif recieved == "2":
27			result = 'Guanyes'
28	elif tool == 1:
29		if recieved == "0":
30			result = 'Guanyes'
31		elif recieved == "2":
32			result = 'Perds'
33	elif tool == 2:
34		if recieved == "0":
35			result = 'Perds'
36		elif recieved == "1":
37			result = 'Guanyes'
38
29	return result
Com podem veure a la definició de la funció, se li passen dues variables: tool i recieved. El més important d’aquest funció és retorn de la variable result. Aquesta variable es retorna al final de la funció.
Com que la funció Comparison(tool, recieved) retorna un valor, al cridar a la funció des del bucle principal while, s’ha d’assignar aquest valor a una variable a l’hora de realitzar la crida. Per aquest motiu, la funció es cridarà de la següent forma:
72	result = Comparison(tool, recieved)
Al cridar-se d’aquesta forma, el valor de la variable retornada s’assigna a la variable de nova definició result. En aquest punt s’ha de fer un incís, encara que les variables es diuen igual: result, són dues variables diferents. La variable result que es defineix a dins de la funció Comparison(tool, recieved) només existeix dins de la funció, no fora de la mateixa. Per contra, la variable result que es defineix a l’interior del bucle while, només existeix a l’interior d’aquest bucle, i a cap lloc més. És el cicle de vida de les variable el que ens permet fer aquesta acció. Per aquest motiu s’ha de tenir sempre molt ben establert i definit quan una variable és global i quan local i quan utilitzar una variable local o una global.
Enviant la resposta
Tal i com està definit el codi, la resposta s’envia automàticament desprès de fer la tirada, i a vegades, si no s’ha fet alhora o ha passat molt de temps entre una i una altre es poden produir errors. Per aquest motiu, modificarem el codi per enviar el resultat de la tirada amb un gest. En aquesta ocasió s’ha triat el gest de tocar el logo de Micro:bit.
Per poder fer això la variació que hem de fer al codi, es la crida a les funció d’enviament mitjançant un bucle if:
69	if pin_logo.is_touched():
70		radio.send(str(tool))
71		recieved=radio.receive()
72
73		result = Comparison(tool, recieved)
74
75		Winner(result)
Amb aquestes modificacions ja tenim el codi més polit i entenedor, però tenim un gran problema: podem fer trampes!
Evitant les trampes
Tal i com tenim definit el codi del projecte hi ha la possibilitat de realitzar trampes i enviar una tirada que sabem que guanyarà. Per evitar això podem utilitzar un bucle if. El que farem serà crear una nova variable global anomenada turns que definirem just abans que el bloc de funcions.
8 # Variables
9 turn = True
El següent pas es modificar el bucle if on es realitza la tirada de la següent manera:
65	if accelerometer.was_gesture('shake') & turn:
D’aquesta manera el bucle if només s’executarà si les dues condicions són certes. Ara, per molt que es realitzi el moviment per una nova tirada, la Micro:bit no donarà cap nou resultat.
El següent pas es treure tot el bucle if on es mira la condició de si s’ha tocat el logo de Micro:bit fora del bucle de la tirada. Al fer-ho sens marcarà que no existeix la variable tool. Això es deu a que aquesta variable és una variable local. La solució és fer que la variable passi a ser global definint-la just a sota de la variable turn.
10 tool = 10
Amb aquestes modificacions el nostre joc ja funciona de forma correcta, però hi ha un petit inconvenient, només podem jugar una partida. Si es vol fer una segona partida s’ha de reiniciar la Micro:bit. Anem a solucionar-ho!
Més d’una partida
Per solucionar aquest fet, el més senzill és crear una nova funció que anomenarem Clean( ) on reiniciarem totes les variables.
A sota la darrera funció definida escriurem:
60 def Clean(tool, turn, result):
61	tool = 10
62	turn = True
63	result = ''
Com es veu, ja aprofitem la nova funció per reiniciar totes les variables al seu valor inicial.
Ara només manca cridar a aquesta funció al final del tot el bucle on enviem la tirada al nostre oponent. Abans de la crida farem que hi hagi una pausa d’uns 2 segons per que els jugadors puguin discutir el resultat de la tirada.
86		sleep(2000)
87
88		Clean(tool, turn, result)
Codi
El codi sencer del projecte es pot veure a la secció XXX de l’apèndix.


Missatge secret
Objectiu
A aquest projecte una continuació el projecte de Codi Morse i el modificarem per que aparegui a la pantalla el text escrit quan sacsegem la Micro:bit. Per fer això ens caldrà declarar una constant on hi ha la conversió de l’alfabet braille a l’alfabet occidental i crear dues variables de tipus array (llista) on anar emmagatzemant els punts i les ratlles i a una altre les lletres introduïdes per formar la paraula.
Comencem!
Creant una constant
Les constants són valors que no es modifiquen al llarg d’un codi i es solen escriure en lletres majúscules per diferenciar+-les de les variables. Al igual que les variables, hi ha diferents tipus de constants.
En el nostre cas utilitzarem un diccionari. Els diccionaris permeten el retorn d’un valor segons els valor que introdueixis, és a dir, hem d’introduir una clau i un valor.
Per exemple:
“.-”: “A“
En aquest cas, quan la Micro:bit detecti a que la variable letter te al seu interior el valor .- (punt i guió) ens retornarà la lletra A.
El diccionari que necessitarem és el següent:
6	# Constant
7	ALPHABET = {
8	 ".-":“A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K”,".-..": "L", "--":"M", "-.":"N", "--.--":"Ñ", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z",
9	 }
Creant les variables
Sobre les variables s’ha de tenir n conte que hi ha variables globals i variables locals. La diferència entre unes i altre és el seu àmbit, el que vindria a ser una espècie de zona d’influència. Les variables globals les declararem sempre a sota de les importacions, i es poden utilitzar a tot el codi del projecte.
Una variable local seria aquella que hem declarat a dins d’un bucle, per exemple. Aquest variable només es pot utilitzar a dins d’aquest bucle, ja que fora del mateix la variable delcara no existeix.
A sota dels imports escriurem:
13	# Variables
14	letter = ‘’
15	word = ‘’
Les variables que hem creat són del tipus string (cadena),. Als projectes de Micro:bit no cal declarar quin tipus de variable estem utilitzant. Per aquest motiu cal inicialitzar-les. És a dir, donar un valor per defecte a les variables. Al fer-ho s’està indicant, de forma indirecta, quin tipus de variable volem utilitzar.
Ara que tenim declarades les variables, anem a utilitzar-les. El primer que farem serà emmagatzemar el valor de · (punt) si pitgem el botó A, o de - (guió) si pitgem el botó B. Per fer-ho, a dins del bucle if del botó A escriurem:
20			letter = letter + '.’)
I a dins del bucle if del botó b escriurem:
39			letter. = letter + ('-')
Amb això estem emmagatzemant el codi que crearà la lletra a la variable letter. Però no estem convertint els punts i guions en lletres. Per fer-ho primer hem d’indicar a la Micro:bit que ja em introduït el codi d’una lletra.
Transformant lletres
Per indicar que ja hem codificat una lletra en codi Morse utilitzarem un gest. En aquest cas s’ha decidit utilitzar un d’aquest dos gestos:
* Inclinar la Micro:bit cap a la dreta.
* Inclinar la Micro:bit cap a l’esquerra.
Aquest bucle if l’escriurem just a sota del bucle del botó B un bucle al que s’accedirà tant si girem la Micro:bit cap a la dreta com si la girem cap a l’esquerra. El bucle tindrà la següent forma:
42	if accelerometer.was_gesture('left') | accelerometer.was_gesture('right'):
Per indicar que el bucle s’executi quan la Micro:bit s’inclini cap a la dreta o cap a l’esquerra hem d’utilitzar l’operador lògic | (o). A l’interior d’aquest bucle declararem un altre bucle if on es comprovarà si existeix el codi Morse a la constant ALPHABET. I en cas de que existeixi afegirem la lletra a la variable word.
Per fer-ho escriure:
44			word = word + ALPHABET[letter]
A aquest línia estem indicant que s’afegeixi a la variable word la transcripció del codi Morse a lletra definida a la constant ALPHABET segons la codificació Morse de la variable Letter.
Per poder anar introduint lletres a la variable letter, hem de reinicialitzar. Això ho farem assignant-li un valor buit un cop hem afegit la lletra a la variable word de la següent manera:
45				letter = ‘’
El següent pas serà afegir una indicació sonora en cas de que s’hagi realitzat la transcripció de forma correcte. Per això afegirem un estímul sonor. A sota de la línia anterior afegirem:
46				music.play(music.POWER_UP)
Ara només ens manca afegir la part del bucle if per si el valor de la variable letter no està continguda al la constant ALPHABET. Per això escriurem:
47		else:
48			music.play(music.POWER_DOWN)
D’aquest forma indicarem que el codi Morse que s’ha introduït no correspon a cap lletra.
Mostrar el missatge amagat
Ara només ens manca que algú pugui veure si escoltar el missatge amagat que ens han deixat escrit a la Micro:bit. Per mostrar el missatge s’ha triat el gest de sacsejar la Micro:bit. Al fer el gest la Micro:bit ens mostrarà per pantalla el missatge i també en dirà.
Per que la Micro:bit parli, al bloc dels imports hem d’importar el mòdul speech.
4	 import speech
El bucle tindrà la següent forma:
54	if accelerometer.was_gesture(‘shake’):
55	display.show(word)
56	speech.say(word)
57	word = ‘’
Com sempre, al final del bucle netegem la variable word per poder deixar una resposta a la Micro:bit.
Codi
El codi sencer del projecte es pot veure a la secció Missatge Secret de l’apèndix.

      Atac de cor a la Micro:bit
Introducció
A aquest projecte modificarem el projecte El batec de la Micro:bit. Aquesta primera pràctica es divideix en dues parts, una primera on es veurà com treballar amb variables i una segona on es veure com utilitzar bucles una mica més complicats al no ser sempre cert (True). També s’incorporen dos nous bucles a la lògica del projecte.
Modificació del Codi
La primera modificació que realitzarem serà la definició de dues variables: a i b. La definició de les variables sempre la farem a la part superior del codi, just a sota de les importacions de les diferents llibreries.
Així dos afegirem les següents línies:
5 # Variables
6	 a = 500
Si mirem el codi antic, ens adonarem que a pren el mateix valor que el valor que es va introduir al mètode sleep( ) i que b pren el valor que es passa al mètode play( ). Així doncs hem de substituir el valor de 500 per a i el de 100 per b dins del mètodes, quedant de la següent forma les línies:
12	music.play(‘c’)
13	sleep(a)
Si ara testem el codi a l’emulador, veurem que no hi ha cap modificació en el comportament. El cor continua bategant i el so es continua produint. El següent pas és modificar el valor de a quan l’usuari realitza alguna acció concreta.
Pitjant botons
L’acció triada per modificar els valors de a, en aquest cas, ha sigut la de pitjar el botó A de la Micro:bit. Per això utilitzarem un bucle if.
A la línia 17 introduirem el següent codi, dins del bucle while:
17		if.button_a.is_pressed():
18			a = a + 50
Mitjançant aquest bucle estem indicant a la Micro:bit que cada cop que l’usuari pitgi el botó A de la Micro:bit el valor d’a s’incrementarà en 50. Si ara testem el codi veurem que al anar pitjant el botó A el batec del cor es va accelerant de forma uniforme.
Ja estem més a prop d’aconseguir un atac al cor. El següent pas serà la modificació del bucle while.
Modificant la condició de while
Ara hem de modificar la condició del bucle while de tal forma que quan a arribi a un valor donat es surti del bucle. En aquest cas hem triat quan a sigui inferior a 50.
Ho farem de la següent forma:
10	while a < 50:
D’aquesta manera s’està indicant que quan el valor d’a sigui superior a 50 s’executi el codi a l’interior del bucle while, però que quan sigui inferior es surti del bucle.
Si ara testem el codi, veurem que quan a assoleix el valor de 50 s’atura l’execució del codi. Ara només ens manca introduir un codi que digui que la Micro:bit ha mort. Per fer això introduirem codi fora del bucle while, que s’executarà quan el valor d’a sigui inferior a 50.
Codi de mort
Fora del bucle while només ens manca incorporar 3 línies de codi per indicar que la Micro:bit ha mort. A partir de la línia 20 escriurem:
20	music.play(‘c’)
22	display.show(Image.SKULL)
Al codi modifiquem el cor que aparegui a la Micro:bit, per una calavera per indicar que la Micro:bit ha mort d’un atac al cor.
Codi
El codi es pot consultar a la secció Atac de cor a la Micro:bit de l’apèndix.


Programació Avançada


El pistoler més ràpid
Introducció
Tenir dos jugadors amb una única Micro:bit pot ser angoixant i poc pràctic. Per aquest motiu, a aquest projecte es modificarà el codi vist a El foraster més ràpid i permetre realitzar una partida amb dos Micro:bits.
En aquest cas donarà igual el botó que es pitgi i les Micro:bits es connectaran per ràdio per saber qui ha guanyat.
Connexió per ràdio
Per poder connectar dues Micro:bits per ràdio el primer que s’ha de fer és importar el mòdul de ràdio. Per aquest motiu, al bloc dels imports escriurem:
5 import radio
Ara ja podem utilitzar el mòdul per connectar les Micro:bits. Per fer-ho definirem una nova funció a sota de la darrera funció i just abans del bucle principal.
Connectant les Micro:bits
La funció per connectar les Micro:bits estarà composta de dues línies i serà de la forma:
38 def players_paring():
39	radio.on()
40	radio.config(group=4)
A aquest funció estem encenent la ràdio i creant un grup de connexió. En aquest cas al grup li hem donat l’identificador de 4, però no vol dir que s’hagin de vincular 4 Micro:bits al grup. El nombre vindria a ser el canal de connexió del grup de Micro:bits.
Ara ja tenim les Micro:bits aparellades. A aquesta funció no la cridarem des de el bucle while principal, la cridarem des de la funció on_shake( ). Que ara serà de la forma:
26 def on_shake(i, press):
27	if accelerometer.is_gesture('shake'):
28		players_pairing()
29
30		if i > 0:
31			countdown(i)
32			music.play(music.JUMP_UP)
33			i = 0
34			press = True
35
36	return press
Com podem veure, hi ha una nova variable anomenada press i s’han eliminat les variables: game, turns player_a i player_b. També s’ha eliminat la funció btn_pressed(btn, result).
Al haver modificat la funció on_shake(3, press) i retornar una variable, es cridarà a la funció assignant-li el valor de la variable retornada segons:
44	press = on_shake(3, result)
També modificarem els bucles if quan es pitja un dels botons. Esborrarem els dos bucles anteriors i definirem un únic que s’activarà es cas de pitjar un o un altre botó.
46	if (button_a.is_pressed() | button_b.is_pressed()) & press:
Aquest bucle s’executarà si es pitjar el botó A o B i sempre i quan s’hagi sacsejat la Micro:bit un cop. Aquesta acció es controla mitjançant el valor de la variable press. Quan aquesta és certa (True) es pot executar el bucle; si no ho és, no es podrà executar el bucle.
A dins del bucle escriurem el següent bloc de codi:
47		radio.send('0')
48		press = False
49		msg = False
50		winner = True
51		music.play('b')
Com es pot observar al bloc de codi superior, hi ha noves variables. Anem a veure les seves funcions.
Les noves variables
La variable press ja l’hem explicat. Aquesta variable ens permet bloquejar la funció de pitjar els botons A i B.
La variable msg és una nova variable, que hem de declarar just a sota de la variable press i que se li assignarà un valor de True. Aquesta variable fa que no es pugui tornar a sacsejar la Micro:bit per realitzar una altre tirada fins que no s’hagi finalitzat la tirada actual.
Per últim, la variable winner, que es defineix amb un valor inicial de False, la definició es realitza sota de la variable msg. Aquesta variable serveix per enviar un missatge de Micro:bit a Micro:bit i bloquejar l’enviament en cas de rebre un missatge. Això ho veurem al següent bloc.
Rebent un missatge
El següent bloc de codi el que fa es veure si hem rebut un missatge. En cas de rebre el missatge, el primer que es fa és bloquejar el codi per evitar que l’altre jugador pugui enviar un missatge. Això es farà modificant el valor de la variable msg. El següent pas es mirar el valor de la variable press i depenent del mateix mostrarà una cara i emetrà un so o un altre.
53	if radio.receive():
52		msg = False
53
54		if press:
55			display.show(Image.ANGRY)
56			music.play(music.POWER_DOWN)
Guanyador de la tirada
Al bloc on es mostra que s’ha guanyat la partida s’accedeix depenent del valor de la variable winner. El que farà aquest bloc és mostrar una cara somrient y una música alegra.
60	if winner:
61		score = score + 1
62		display.show(Image.HAPPY)
63		music.play(music.POWER_UP)
Reiniciant el joc
Ara ja tenim el joc funcionant i es pot decidir qui ha guanyat la tirada, però hauríem de fer un joc més llarg, on hi hagin al mínim cinc (5) tirades i dir qui és el guanyador la partida. EL guanyador, serà el primer que arribi a tres (3) tirades guanyadores.
Per tant, el que hem de fer es emmagatzemar alguns valors i reiniciar algunes variables per poder tornar a executar el joc. La reinicialització es realitzarà si es porten menys de cinc (5) tirades.
65	if pin_logo.is_touched():
66		rounds = rounds + 1
67
68		if rounds < 5:
69			msg = True
70		else:
71			if score >= 3:
72				speech.say('Guanyes')
73				display.show(Image.FABULOUS)
74				music.play(music.PYTHON)
75			else:
76				speech.say('Perds')
77				display.show(Image.SKULL)
78				music.play(music.FUNERAL)
Ara ja només ens queda gravar el codi a dues Micro:bits i iniciar una partida!
El codi
El codi d’aquest projecte es pot veure tot sencer a la secció El pistoler més ràpid de l’apèndix.

Tria tu
Introducció
   Aquest projecte és un pas més del projecte anomenat Un contra l’altre. A l’anterior projecte era l’atzar qui triava entre pedra, paper i tisora. A aquest és el jugador el que triarà la seva tirada mitjançant alguna d’aquestes accions:
* Pitjar el botó A.
* Pitjar el botó B.
* Pitjar el logo de Micro:bit.
Així que... anem a modificar el codi!
Substituint el bucle if accelerometer.was_gesture('shake') & turn
El primer que hem de fer és agafar tot el que hi ha dins el bucle on iniciem la tirada i crear tres (3) bucle nous.
Els bucles nous miraran si s’ha pitjat el botó A, el B o el logo de la Micro:bit per veure quina tirada ha decidit efectuar el jugador. Els bucles tindran la següent forma:
69	if button_a.was_pressed() & turn:
70		turn = False
71		tool = 0
72
73		Trie(tool)
74
75	elif button_b.was_pressed() & turn:
76		turn = False
77		tool = 1
78
79		Trie(tool)
80
81	elif pin_logo.is_touched() & turn:
82		turn = False
83		tool = 3
84
85		Trie(tool)
86
87	sleep(500)
Amb aquesta modificació estem fent que el jugador trii la seva jugada i que no sigui l’atzar qui la trii per ell.
Modificant la condició d’enviament
La següent modificació a realitzar serà el gest d’enviament. Al projecte anterior utilitzàvem el gest de tocar el logo de la Micro:bit; ara aquest gest és triar les tisores com tirada. Al tenir disponible el gest de sacsejar la Micro:bit, utilitzarem aquest gest per enviar la nostra tirada al contrincant. Per tant la condició del bucle quedarà de la següent manera:
92	if accelerometer.was_gesture('shake'):
Amb això ja tindríem finalitzat el nostre projecte. Però realitzar una única partida és una mica trist, així que anem a desenvolupar una mica més el codi per que guanyi el millor a 5 tirades.
Afegint un comptador
El que farem per afegir dos comptadors. Per això crearem dues noves variables: count i points. A la primera variable es contaran les tirades que no són empats i a la segona les tirades que em guanyat.
11 count = 0
12 points = 0
Un cop creades les variables, a dins del bucle on enviem la tirada i abans d’esborrar totes les variables, funció Clean( ), escriurem:
103		if result != 'Empatas':
104			count = count + 1
Amb aquest bucle estem incrementant el valor de la variable count quan no es produeix un empatat.
Contant tirades guanyades
Les tirades guanyadores, les anirem sumant a la variable points. Per fer-ho crearem un bucle a dins del bucle on s’envia la tirada a l’oponent.
98		if result == 'Guanyes':
99			points = points + 1
Ara, si guanyem sumarem un punt al nostre marcador.
Proclamant un guanyador
El següent pas serà anunciar el guanyador de la partida. Per fer-ho es mirarà qui té més de 3 victòries un cop s’han realitzat les 5 tirades. Això es farà mitjançant un bucle if dins del bucle on es valora que la variable count ha arribat a 5, de la següent manera:
113		if points > 2:
114			display.show(Image.HAPPY)
115			speech.say('Guanyes')
116			music.play(music.PYTHON)
117		elif points < 3:
118			display.show(Image.SKULL)
119			speech.say('Perds')
120			music.play(music.FUNERAL)
Com podem observar, estem utilitzant imatges i sons que hem utilitzat dins la funció Winner( ). Aquest fet és contraproduent pels usuaris, ja que al rebre una informació diferent amb el mateix so i la mateixa imatge que una victòria parcial, pot pensar que simplement ha guanyat la tirada i no la partida. Per aquest fet, s’han de modificar els sons i les imatges dins la funció Winner( ).
El codi
El codi complet del projecte es pot veure a la secció Tria tu de l’apèndix.


Enviant un missatge
Objectiu
A aquest projecte tornarem a modificar el codi del projecte Missatge secret per enviar un missatge entre dues Micro:bit i que una altre persona el pugui llegir.
Per això, ens caldrà realitzar una connexió entre les dues Micro:bits.
Enviem missatges!
Imports
Als imports que ja teníem afegirem el que permet connectar dues Micro:bit. Així, a sota de la darrera línia del bloc d’imports afegirem:
5 import radio
El següent pas serà crear un gest per enviar el missatge escrit. Per fer-ho utilitzarem el gest de sacsejar la Micro:bit.
Enviant el missatge
Per enviar el missatge esborrarem el codi escrit a dins del bucle per mostrar el missatge i el substituirem per:
56		radio.send(word)
57
58		if radio.receive():
59			msg = radio.receive()
60
61			if msg:
62				display.scroll(msg)
63				speech.say((msg))
Amb aquest codi estem enviant el missatge escrit per un usuari i rebent-lo a l’altre Micro:bit. Un cop es rep el missatge la Micro:bit el mostra en pantalla i el llegeix.
El codi
El codi complert del projecte es pot veure a la secció Enviant un missatge de l’apèndix.


El cor de la Micro:bit
Introducció
A aquest projecte reprendrem el projecte Atac de cor a la Micro:bit que vam veure a Programació Intermèdia. Ara complicarem una mica més el codi al imposar condicions variables mitjançant l’ús de lògic i utilitzarem el botó B de la Micro:bit per alentir el batec del cor i fer que la Micro:bit pugui morir per un atac de cor o per una aturada cardíaca.
El cor
El cor humà fa, de mitja, entre 60 i 100 batecs per minut. Per tant, el primer que farem és modificar el ritme cardiaqui del nostre projecte. Al projecte estàvem fent que el cor bateguès cada 500 mil·lisegons, això és 2 batecs cada segon. Volem que el cor ara bategui 80 cops per minut, és a dir, 1.3 cops per segon o 1.3 cada 1000 mil·lisegons.
Batecs/MinutBatecs/SegonsFreqüència6011801.330.751001.670.6Taula 1Batecs de cor per minut, segon i freqüència.
Al codi no podem dir que aparegui 1.3 cops cada 1000 mil·lisegons. Per tant, hem de realitzar una conversió. Podem fer que aquesta conversió la realitzi la Micro:bit si la codifiquem al nostre codi. Però per fer-ho, abans hem de pensar en l’algoritme (funció) necessari. Pensem!
Tenim 1.3 batecs cada 1000 mil·lisegons i volem saber cada quants mil·lisegons es realitza 1 batec. Per tant:
1.33batecs/(1000 Mil·lisegons)=1batec/(X Mil·lisegons)
X=1000/1.3
X=769.23
És a dir, la Micro:bit farà 1 batec cada 769.23 mil·lisegons.
Modificant el codi
El primer pas serà la modificació del valor de les variables per simular el batec d’un cor a la Micro:bit segons el batec d’un cor humà.
Tal i com hem vist al punt anterior, el nou valor de la variable a ha d’ésser 769.23 i b 75, que és la freqüència corresponent a 80 batecs/minut. D’aquesta forma hem replicat el batec d’un cor humà a la nostre Micro:bit.
Així doncs, les línies 6 i 7 quedaran de la forma:
6	a = 769.23
7	b = 75
El següent pas serà crear un nou bucle per reduir el batec del cor si l’usuari pitja el botó B de la Micro:bit.
Reduint el batec
Per reduir el batec del cor crearem un bucle if molt similar al que es va crear per botó A de la Micro:bit (línia 17). A la línia 21 escriurem:
17		If button_b.is_pressed():
18			a = a + 50
Aquest bucle if s’ha d’escriure dins el buecle while, i el que fa es augmentar el valor de la variable a i per tant s’ampliarà el temps entre batecs, reduint-se la freqüència.
Si testem ara el projecte veurem que podem incrementar la velocitat de batec fins a un màxim però que per contre, no hi ha un límit per reduir la velocitat de batec.
Modificant la condició del bucle while
Per introduir una nova condició per que s’executi el bucle while, crearem una nova variable anomenada lives. Aquesta variable la crearem de tipus booleà.
8	lives = True
Les variable de tipus booleà són unes variables que només poden agafar dos valors: cert (True) o fals (False).
Amb aquesta nova variable definida, fem la següent modificació al bucle while:
11	while lives:
Si testem ara el codi veuríem que el cor bategaria constantment. Això es deu a que no em vinculat el valor de la variable a al valor de la variable lives, i per tant la condició és certa sempre.
Per vincular aquestes variables introduirem un nou bucle if a dins del bucle while. A la línia 24 escriurem:
24		If a < 598.80 or a > 1000:
25			lives = false
Aquest bucle if és una mica diferent als que hem utilitzat amb anterioritat. En ell s’està dient que si el valor de la variable a és inferior (<) a 598.80 o (or) és superior a 1000 el valor de la variable lives serà False.
Si ara testem el codi del projecte, veurem que el cor de la Micro:bit deixa de bategar si accelerem molt el seu batec o si el disminuïm. Ja podem dir que hem simulat el batec de un cor humà a una Micro:bit, però anem a fer una darrera millora al codi del nostre projecte.
Darreres modificacions
Emprant la mateixa lògica que hem utilitzat al darrer bucle if que hem vist, anem a modificar els bucles if que controlen la modificació de la variable a, de manera que es pugui incrementar o disminuir el seu valor prement els botons de la Micro:bit o realitzant un altre gest. En aquest cas s’ha triat que al sacsejar la Micro:bit s’incrementarà la velocitat de batec i al acaronar el logotip de la Micro:bit es redueix la velocitat de batec.
Per tant, la línia 18 quedarà de la següent forma:
18		if button_a.is_pressed() or accelerometer.was_gesture(‘shake’):
i la línia 21:
21		if button_b.is_pressed() or pin_logo.is_touched():
Ara, podem comprovar que al realitzar qualsevol dels 4 gestos descrits es modifica la velocitat de batec del cor de la Micro:bit.
Comentaris
Com s’ha vist, un atac al cor no implica que un cor acceleri molt el seu batec o el disminueixi. L’atac no implica que la freqüència cardíaca augmenti o disminueixi de forma considerable, o perceptible. Així que si es vol fer el joc més divertit, es poden modificar els límits de la variable a i establir-ho a 100 i 1500 per veure com estem augmentant i disminuint el batec al realitzar els diferents gestos.
El codi
Es pot consultar el codi sencer a l’apartat El cor de la Micro:bit de l’apèndix.
Apèndix

Apèndix

El més ràpid
1 # Imports
2 from microbit import *
3 import music
4
5 # Main loop
6 while True:
7	if button_a.is_pressed():
8		display.shoe(Image.ARROW_W))
9		music.play(‘a’)
10	if button_b.is_pressed():
11		display.shoe(Image.ARROW_E))
12		music.play(‘b’)

Pedra, Paper, Tisora
1 # Imports
2 from microbit import *
3 import random
4 import speech
5 import music
6
7 # Main loop
8 while True:
9		if accelerometer.was_gesture('shake'):
10		tool = random.randint(0,2)
11		if tool == 0:
12			display.show(Image.SQUARE_SMALL)
13			speech.say('Pedra')
14			music.play(music.RINGTONE)
15		elif tool == 1:
16			display.show(Image.SQUARE)
17			speech.say('Paper')
18			music.play(music.JUMP_DOWN)
19		else:
20			display.show(Image.SCISSORS);
21			speech.say('Tisores')
22			music.play(music.JUMP_UP)

Codi Morse
1 # Imports
2 from microbit import *
3 import music
4
5 # Main loop
6 while True:
7	if button_a.is_pressed():
8		display.show(Image(‘00000:’
9					‘00000:’
10					‘00900:’
11					‘00000:’
12					‘00000:’
13					))
14		music.play(‘a’)
15	if button_b.is_pressed():
16		display.show(Image(‘00000:’
17					‘00000:’
18					‘09990:’
19					‘00000:’
20					‘00000:’
21					))
22		music.play(‘b’)
23	sleep(1000)
24	display.clear()


El batec de la Micro:bit
1 # Imports
2 form microbit import *
3 import music
4
5 # Main loop
6 while True:
7	display.show(Image.HEART)
8	music.play(‘a’)
9	sleep(500)
10	display.show(Image.HEART_SMALL)
11	sleep(500)


Conta enrere
1 # Imports
2 from microbit import *
3 imort music
4
5 # Variables
6 i = 10
7
8 # Main loop
9 for index in range(11):
10	display.show(j)
11	music.play(‘a’)
12	i = i – 1
13	sleep(1000)


El foraster més ràpid
1 # Imports
2 from microbit import *
3 import music
4 import speech
5
6 # Variables
7 game = True
8 turns=5
9 player_a=0
10 player_b=0
11
12 # Functions
13 def countdown(i):
14 	while i>0:
15		for n in range(3):
16			display.show(i)
17			music.play('a')
18			sleep(500)
19			i=i-1
20
21		if i==0:
22			display.show(0)
23
24 def btn_pressed(btn):
25	if btn == 0:
26		display.show(Image.ARROW_W)
27		music.play('a')
28
29	elif btn == 1:
30		display.show(Image.ARROW_E)
31		music.play('b')
32
33	sleep(1000)
34	display.clear()
35	music.play(music.JUMP_DOWN)
35
37 def on_shake(i):
38	if accelerometer.is_gesture('shake'):
39		if i > 0:
49			countdown(i)
41			music.play(music.JUMP_UP)
42			i = 0
43
44 # Main loop
45 while game:
46	on_shake(3)
47
48	if button_a.is_pressed():
49		btn_pressed(0)
50		turns = turns - 1
51		player_a = player_a + 1
52		on_shake(3)
53
54	if button_b.is_pressed():
55		btn_pressed(1)
56		turns = turns - 1
57		player_b = player_b + 1
58		on_shake(3)
59
60	if turns == 0:
61		game = False
62
63		if player_a > player_b:
64			display.show('A')
65			speech.say('Jugador A gana')
66		elif player_b > player_a:
67			display.show('B')
68			speech.say('Jugador B gana')


Un contra l’altre
1 # Imports
2 from microbit import *
3 import random
4 import speech
5 import music
6 import radio
7
8 # Variables
9 turn = True
10 tool = 10
11
12 # Functions
13 def Trie(tool):
14	if tool == 0:
15		display.show(Image.SQUARE_SMALL)
16		speech.say('Pedra')
17	elif tool == 1:
18		display.show(Image.SQUARE)
19		speech.say('Paper')
20	else:
21		display.show(Image.SCISSORS);
22		speech.say('Tisores')
23
24 def Comparison(tool, recieved):
25	result = ''
26
27	if tool == 0:
28		if recieved == "1":
29			result = 'Perds'
30		elif recieved == "2":
31			result = 'Guanyes'
32	elif tool == 1:
33		if recieved == "0":
34			result = 'Guanyes'
35		elif recieved == "2":
36			result = 'Perds'
37	elif tool == 2:
38		if recieved == "0":
39			result = 'Perds'
40		elif recieved == "1":
41			result = 'Guanyes'
42
43	return result
44
45 def Winner(result):
46	if result == 'Guanyes':
47		display.show(Image.SMILE)
48		music.play(music.PYTHON)
49		speech.say('Guanyes')
50	elif result == 'Perds':
51		display.show(Image.SAD)
52		music.play(music.FUNERAL)
53		speech.say('Perds')
54	elif result == 'Empatas':
55		display.show(Image.ASLEEP)
56		music.play(music.WAWAWAWAA)
57		speech.say('Empat')
58
59 def Clean(tool, turn, result):
60	tool = 10
51	turn = True
62	result = ''
63
64 # Main loop
65 while True:
66
67	radio.config(group=12)
68
69	if accelerometer.was_gesture('shake') & turn:
70		turn = False
71		tool = random.randint(0,2)
72
73		Trie(tool)
74
75		sleep(500)
76
77	if pin_logo.is_touched():
78		radio.send(str(tool))
79		recieved=radio.receive()
80
81		result = Comparison(tool, recieved)
82
83		Winner(result)
84
85		sleep(2000)
86
87		Clean(tool, turn, result) 

Missatge Secret
1 # Imports
2 from microbit import *
3 import music
4 import speech
5
6 # Constants
7 ALPHABET = {
    ".-":"A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K", ".-..":"L", "--":"M", "-.":"N", "--.--":"Ñ", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z",
9 }
10
11 # More conversions (not used in the project)
12 # "-----":"0", ".----":"1", "..---":"2", "...--":"3", "....-":"4", ".....":"5", "-....":"6", "--...":"7", "---..":"8", "----.":"9", ".-.-.-":".", "--..--":",", "---...":":", "..--..":"?", ".----.":"'", "-....-":"-", "-..-.":"/", ".-..-.":"\"", ".--.-.":"@", "-...-":"=", "?.?.??":"!"
13
14 # Variables
15 letter = ''
16 word = ''
17
18 # Main loop
19 while True:
20	if button_a.is_pressed():
21		display.show(Image('00000:'
22				'00000:'
23				'00900:'
24				'00000:'
25				'00000'
26				))
27
28		music.play('a')
29		letter = letter + '.'
30
31	if button_b.is_pressed():
32		display.show(Image('00000:'
33				'00000:'
34				'09990:'
35				'00000:'
36				'00000'
37			))
38
39		music.play('b')
40		letter = letter + '-'
41
42	if accelerometer.was_gesture('left') | accelerometer.was_gesture('right'):
43		if letter in ALPHABET:
44			word = word + ALPHABET[letter]
45			music.play(music.POWER_UP)
46			letter = ''
47		else:
48			music.play(music.POWER_DOWN)
49
50	sleep(1000)
51	display.clear()
52
53	if accelerometer.was_gesture('shake'):
54		display.show(word)
55		speech.say((word))


Atac de cor a la Micro:bit
1 # Imports go at the top
2 from microbit import *
3 import music
4
5 # Variables
6 a = 500
7 b = 100
8
9 # Code in a while a > 50 or a < 1000 executes if a value is between 50 and 1000
10 while a > 50:
11	display.show(Image.HEART)
12	music.play('c')
13	sleep(a)
14	display.show(Image.HEART_SMALL)
15	sleep(a)
16
17	if button_a.is_pressed():
18		a = a - 50
19
20 b = 200
21 music.pitch(b)
22 display.show(Image.SKULL)


El pistoler més ràpid
1 # Imports
2 from microbit import *
3 import music
4 import speech
5 import radio
6
7 # Variables 
8 rounds = 0
9 score = 0
10 msg = True
11 press = False
12 winner = False
13
14 # Funtions
15 def countdown(i):
16	while i > 0:
17		for n in range(4): 
18			display.show(i)
19			music.play('d') 
20			sleep(1000)
21			i = i - 1
22
23		if i == 0:
24			display.show(0)
25
26 def on_shake(i, press):
27	if accelerometer.is_gesture('shake'):
28		players_pairing()
29
30		if i > 0:
31			countdown(i)
32			music.play(music.JUMP_UP)
33			i = 0
34			press = True
35
36	return press
37
38 def players_pairing():
39	radio.on()
40	radio.config(group=4)
41
42 # Main loop
43 while msg:
44	press = on_shake(3, press)
45
46	if (button_a.is_pressed() | button_b.is_pressed()) & press:
47		radio.send('0')
48		press = False
49		msg = False
50		winner = True
51		music.play('b')
52
53	if radio.receive():
54		msg = False
55
56		if press:
57			display.show(Image.ANGRY)
58			music.play(music.POWER_DOWN)
59
60	if winner:
61		score = score + 1
62		display.show(Image.HAPPY)
63		music.play(music.POWER_UP)
64
65	if pin_logo.is_touched():
66		rounds = rounds + 1
67
68		if rounds < 5:
69			msg = True
70		else:
71			if score >= 3:
72				speech.say('Guanyes')
73				display.show(Image.FABULOUS)
74				music.play(music.PYTHON)
75			else:
76				speech.say('Perds')
77				display.show(Image.SKULL)
78				music.play(music.FUNERAL)


Tria tu
1 # Imports
2 from microbit import *
3 import random
4 import speech
5 import music
6 import radio
7
8 # Variables
9 turn = True
10 tool = 10
11 count = 0
12 points = 0
13
14 # Functions
15 def Trie(tool):
16	if tool == 0:
17		display.show(Image.SQUARE_SMALL)
18		speech.say('Pedra')
19	elif tool == 1:
20		display.show(Image.SQUARE)
21		speech.say('Paper')
22	else:
23		display.show(Image.SCISSORS);
24		speech.say('Tisores')
25
26 def Comparison(tool, recieved):
27	result = ''
28
29	if tool == 0:
30		if recieved == "1":
31			result = 'Pierdes'
32		elif recieved == "2":
33			result = 'Ganas'
34	elif tool == 1:
35		if recieved == "0":
36			result = 'Ganas'
37		elif recieved == "2":
38			result = 'Pierdes'
39	elif tool == 2:
40		if recieved == "0":
41			result = 'Pierdes'
42		elif recieved == "1":
43			result = 'Ganas'
44
45	return result
46
47 def Winner(result):
48	if result == 'Ganas':
49		display.show(Image.SMILE)
50		music.play(music.POWER_UP)
51		speech.say('Ganas')
52	elif result == 'Pierdes':
53		display.show(Image.SAD)
54		music.play(music.POWER_DOWN)
55		speech.say('Pierdes')
56	elif result == 'Empatas':
57		display.show(Image.ASLEEP)
58		music.play(music.WAWAWAWAA)
59		speech.say('Empate')
60
61 def Clean(tool, turn, result):
62	tool = 10
63	turn = True
64	result = ''
65
66 # Main loop
67 while True:
68
69	radio.config(group=12)
70
71	if button_a.was_pressed() & turn:
72		turn = False
73		tool = 0
74
75		Trie(tool)
76
77	elif button_b.was_pressed() & turn:
78		turn = False
79		tool = 1
80
81	elif pin_logo.is_touched() & turn:
82		turn = False
83		tool = 3
84
85	Trie(tool)
86	sleep(500)
87
88	if accelerometer.was_gesture('shake'):
89		radio.send(str(tool))
90		recieved=radio.receive()
91
92		if recieved:
93			result = Comparison(tool, recieved)
94
95			if result == 'Ganas':
96			points = points + 1
97
98			Winner(result)
99
100			if result != 'Empatas':
101				count = count + 1
102
103			sleep(2000)
104
105			if count < 5:
106				count = count + 1
107				Clean(tool, turn, result)
108
109			elif count > 5:
110				if points > 2:
111					display.show(Image.HAPPY)
112					speech.say('Ganas')
113					music.play(music.PYTHON)
114				elif points < 3:
115					display.show(Image.SKULL)
116					speech.say('Pierdes')
117					music.play(music.FUNERAL)

Enviant un missatge
1 # Imports
2 from microbit import *
3 import music
4 import speech
5 import radio
6
7 # Constants
8 ALPHABET = {
9 ".-":"A", "-...":"B", "-.-.":"C", "-..":"D", ".":"E", "..-.":"F", "--.":"G", "....":"H", "..":"I", ".---":"J", "-.-":"K", ".-..":"L", "--":"M", "-.":"N", "--.--":"Ñ", "---":"O", ".--.":"P", "--.-":"Q", ".-.":"R", "...":"S", "-":"T", "..-":"U", "...-":"V", ".--":"W", "-..-":"X", "-.--":"Y", "--..":"Z",
}
10
11 # More conversions (not used in the project)
12 # "-----":"0", ".----":"1", "..---":"2", "...--":"3", "....-":"4", ".....":"5", "-....":"6", "--...":"7", "---..":"8", "----.":"9", ".-.-.-":".", "--..--":",", "---...":":", "..--..":"?", ".----.":"'", "-....-":"-", "-..-.":"/", ".-..-.":"\"", ".--.-.":"@", "-...-":"=", "?.?.??":"!"
13
14 # Variables
15 letter = ''
16 word = ''
17
18 # Main loop
19 while True:
20	if button_a.is_pressed():
21		display.show(Image('00000:'
22			'00000:'
23			'00900:'
24			'00000:'
25			'00000'
26			))
27
28		music.play('a')
29		letter = letter + '.'
30
31	if button_b.is_pressed():
32		display.show(Image('00000:'
33			'00000:'
34			'09990:'
35			'00000:'
36			'00000'
37			))
38
39		music.play('b')
40		letter = letter + '-'
41
42	if accelerometer.was_gesture('left') | accelerometer.was_gesture('right'):
43		if letter in ALPHABET:
44			word = word + ALPHABET[letter]
45			music.play(music.POWER_UP)
46			letter = ''
47		else:
48			music.play(music.POWER_DOWN)
49
50	sleep(1000)
51	display.clear()
52
53	if accelerometer.was_gesture('shake'):
54		radio.send(word)
55
56	if radio.receive():
57		msg = radio.receive()
58
59		if msg:
60			display.scroll(msg)
61			speech.say(msg)

El cor de la Micro:bit
1 # Imports go at the top
2 from microbit import *
3 import music
4
5 # Variables
6 a = 769.23
7 b = 75
8 lives = True
9
10 # Main loop
11 while lives:
12	display.show(Image.HEART)
13	music.pitch(b)
14	sleep(a)
15	display.show(Image.HEART_SMALL)
16	sleep(a)
17
18	if button_a.is_pressed() or accelerometer.was_gesture('shake'):
19		a = a - 50
20
21	if button_b.is_pressed() or pin_logo.is_touched():
22		a = a + 50
23
24	if a < 100 or a > 1500:
25		lives = False
26
27 b = 200
28 music.pitch(b)
29 display.show(Image.SKULL)
