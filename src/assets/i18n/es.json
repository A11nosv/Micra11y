{
  "ACCESSIBILITY": {
    "LANGUAGE_BUTTON_LABEL": "Idioma actual {{language}} pulse para modificar idioma"
  },
  "TABS": {
    "MICROPYTHON": "MicroPython",
    "MICROBIT": "Micro:bit",
    "MICROIA": "MicroIA",
    "REPOSITORIO": "Repositorio"
  },
  "MICROBIT_PAGE": {
    "TITLE": "Proyectos Micro:bit",
    "OPEN_PROJECT_PREFIX": "Abrir el proyecto ",
    "PROJECTS": {
      "ACCESSIBLE_PROGRAMMING": {
        "TITLE": "Programación Accesible",
        "DESCRIPTION": "Explora la programación de Micro:bit de forma accesible.",
        "img": "assets/img/microbit-a11y.png",
        "alt": "Imagen representativa de la programación accesible con Micro:bit"
      },
      "COUNTDOWN": {
        "TITLE": "La Cuenta Atrás Final",
        "DESCRIPTION": "Una cuenta atrás personalizable.",
        "img": "assets/img/final-countdown.png",
        "alt": "Imagen de una cuenta atrás"
      },
      "DUEL": {
        "TITLE": "Duelo al Sol",
        "DESCRIPTION": "Un juego de reflejos para dos jugadores.",
        "img": "assets/img/duel.png",
        "alt": "Imagen de un duelo con Micro:bit"
      },
      "STONE_PAPER_SCISSORS": {
        "TITLE": "Piedra, Papel, Tijera",
        "DESCRIPTION": "El clásico juego, ahora en tu Micro:bit.",
        "img": "assets/img/rps.png",
        "alt": "Imagen del juego Piedra, Papel, Tijera con Micro:bit"
      },
      "SECRET_MESSAGE": {
        "TITLE": "Mensaje Secreto",
        "DESCRIPTION": "Envía y recibe mensajes secretos.",
        "img": "assets/img/morse_code.png",
        "alt": "Imagen de un mensaje secreto con Micro:bit"
      },
      "HEARTBEAT": {
        "TITLE": "El Latido de la Micro:bit",
        "DESCRIPTION": "Visualiza el latido de tu placa.",
        "img": "assets/img/heart.png",
        "alt": "Imagen del latido del corazón con Micro:bit"
      }
    }
  },
  "DUEL_PAGE": {
    "TITLE": "Duelo al Sol",
    "VIDEO_NOT_SUPPORTED": "Tu navegador no es compatible con la etiqueta de video.",
    "INTRODUCTION_TITLE": "Introducción",
    "INTRODUCTION_TEXT": "Este proyecto te enseña a crear un juego de reflejos para dos jugadores en la Micro:bit. ¡Prepárate para el duelo!",
    "MATERIALS_TITLE": "Materiales",
    "MATERIALS_LIST": [
      "2 Micro:bits",
      "Ordenador portátil",
      "Cable de conexión USB-A",
      "Editor de Python"
    ],
    "TARGET": "Objetivo",
    "TARGET_TEXT_1": "Crear un juego de reflejos simple para dos jugadores utilizando dos Micro:bits.",
    "TARGET_TEXT_2": "Practicar la programación de bucles, condicionales e interacción entre Micro:bits.",
    "STEPS_TITLE": "Pasos para la Programación",
    "STEP_1_TITLE": "Paso 1: El Lanzamiento del Duelo",
    "STEP_1_TEXT": "Comenzaremos programando la lógica básica del juego, donde los jugadores deben reaccionar rápidamente.",
    "STEP_1_TEXT_1": "Para ello, introduciremos una función de cuenta atrás y un mecanismo para detectar la presión de los botones.",
    "STEP_1_TEXT_2": "Aquí tienes el primer fragmento de código para la cuenta atrás inicial:",
    "STEP_1_TEXT_3": "Este código mostrará una cuenta atrás en la pantalla de la Micro:bit y emitirá un sonido.",
    "STEP_1_TEXT_4": "Después de la cuenta atrás, la Micro:bit debe esperar a que uno de los jugadores pulse el botón A o B.",
    "STEP_1_TEXT_5": "El siguiente fragmento de código gestiona la detección de la presión de los botones:",
    "STEP_1_TEXT_6": "Estas líneas detectan qué botón se pulsa primero y muestran una flecha en la dirección correspondiente.",
    "STEP_2_TITLE": "Paso 2: Mejorando la Interactividad",
    "STEP_2_TEXT": "Ahora añadiremos elementos para hacer el juego más dinámico e interactivo.",
    "STEP_2_TEXT_1": "Integración de sonido para la retroalimentación:",
    "STEP_2_TEXT_2": "El sonido ayudará a los jugadores a saber cuándo comienza y termina la cuenta atrás, y quién ha pulsado primero.",
    "STEP_2_TEXT_3": "También añadiremos una variable para controlar el estado del juego, como si el duelo está activo o no.",
    "STEP_2_TEXT_4": "Aquí tienes el código actualizado con la lógica de sonido y estado del juego:",
    "STEP_2_TEXT_5": "Este paso es crucial para una experiencia de juego accesible.",
    "STEP_3_TITLE": "Paso 3: Conectando las Micro:bits",
    "STEP_3_TEXT": "El duelo será más emocionante si las dos Micro:bits pueden comunicarse entre ellas.",
    "STEP_3_TEXT_1": "Utilizaremos el módulo de radio para enviar señales entre las dos Micro:bits.",
    "STEP_3_TEXT_2": "Primero, configuramos el canal de radio para que las Micro:bits puedan encontrarse:",
    "STEP_3_TEXT_3": "Este fragmento de código inicializa la radio y la configura a un grupo específico.",
    "STEP_3_TEXT_4": "Ahora, cuando un jugador pulse un botón, su Micro:bit enviará un mensaje a la otra.",
    "STEP_3_TEXT_5": "El siguiente código muestra cómo enviar y recibir estos mensajes:",
    "STEP_3_TEXT_6": "La Micro:bit que recibe el mensaje debe saber que el otro jugador ha reaccionado.",
    "STEP_3_TEXT_7": "Gestionaremos el resultado del duelo en función de quién pulsa primero y quién recibe el mensaje.",
    "STEP_3_TEXT_8": "Aquí tienes el código para la lógica de envío y recepción de mensajes:",
    "STEP_3_TEXT_9": "Esta lógica determina el ganador de cada ronda del duelo.",
    "STEP_3_TEXT_10": "La comunicación por radio es fundamental para la dinámica del juego.",
    "STEP_4_TITLE": "Paso 4: Añadiendo Puntuación y Múltiples Rondas",
    "STEP_4_TEXT": "Para hacer el juego más competitivo, añadiremos un sistema de puntuación y la posibilidad de jugar varias rondas.",
    "STEP_4_TEXT_1": "Declararemos variables para las puntuaciones de cada jugador y para el número de rondas jugadas.",
    "STEP_4_TEXT_2": "El juego finalizará después de un número predefinido de rondas, y el ganador será el que tenga la puntuación más alta.",
    "STEP_4_TEXT_3": "Aquí tienes el código para gestionar la puntuación y las rondas:",
    "STEP_4_TEXT_4": "Estas variables se actualizarán después de cada ronda.",
    "STEP_4_TEXT_5": "También necesitamos una manera de reiniciar el juego para una nueva partida.",
    "STEP_4_TEXT_6": "La función de reinicio se encargará de restablecer las puntuaciones y las rondas.",
    "STEP_4_TEXT_7": "Código para reiniciar el juego:",
    "STEP_4_TEXT_8": "Esto permitirá jugar varias partidas sin necesidad de reiniciar las Micro:bits.",
    "STEP_4_TEXT_9": "La puntuación visible en cada Micro:bit ayudará a los jugadores a seguir el progreso.",
    "STEP_4_TEXT_10": "Ajustaremos las salidas visuales y sonoras para anunciar el ganador final.",
    "STEP_4_TEXT_11": "El código final debería integrar todas estas partes para un juego completo y funcional.",
    "STEP_4_TEXT_12": "Este sistema de puntuación añade un elemento de competición al duelo."
  },
  "HEART_PAGE": {
    "TITLE": "El Latido de la Micro:bit",
    "VIDEO_NOT_SUPPORTED": "Tu navegador no soporta la etiqueta de video.",
    "INTRODUCTION_TITLE": "Introducción",
    "INTRODUCTION_TEXT": [
      "Este proyecto nos permite visualizar el latido de la Micro:bit y experimentar con el ritmo cardíaco.",
      "Aprenderemos a utilizar la pantalla de LEDs para representaciones visuales y a integrar sonidos para una retroalimentación multisensorial.",
      "Descubriremos cómo se puede variar el ritmo del 'latido' utilizando diferentes controles y programación.",
      "¡Prepárate para sentir el pulso de tu Micro:bit!"
    ],
    "MATERIALS_TITLE": "Materiales",
    "MATERIALS_LIST": [
      "1 Micro:bit",
      "Ordenador portátil",
      "Cable de conexión USB-A",
      "Editor de Python"
    ],
    "STEPS_TITLE": "Pasos para la Programación",
    "STEP_1_TITLE": "Paso 1: El Corazón Cobra Vida",
    "STEP_1_TITLE_1": "El Latido Básico",
    "STEP_1_TEXT": "Comenzaremos programando una animación sencilla de un corazón que late en la pantalla de LEDs de la Micro:bit.",
    "STEP_1_TITLE_2": "Añadiendo Sonido al Latido",
    "STEP_1_TEXT_1": "Para hacer el latido más realista y accesible, añadiremos un sonido cada vez que el corazón se ilumine.",
    "STEP_1_TEXT_2": [
      "Importaremos el módulo 'music' para poder reproducir notas musicales.",
      "El sonido debería ser claro y distintivo, replicando el 'lub-dub' de un latido real."
    ],
    "STEP_1_TEXT_3": "Aquí tienes el código para integrar el sonido con la animación del corazón:",
    "STEP_1_TITLE_3": "Controlando el Ritmo",
    "STEP_1_TEXT_4": "Ahora que el corazón late y suena, queremos poder controlar su ritmo. Introduciremos una variable 'beats' para ajustar la velocidad del latido.",
    "STEP_1_TEXT_5": [
      "Esta variable controlará el tiempo de espera entre cada 'latido' y la duración de las notas musicales.",
      "Experimentaremos con diferentes valores para encontrar el ritmo adecuado."
    ],
    "STEP_1_TITLE_4": "Interacción con Botones",
    "STEP_1_TEXT_6": [
      "Haremos que los botones A y B de la Micro:bit permitan a los usuarios aumentar o disminuir la velocidad del latido.",
      "Pulsar el botón A podría acelerar el corazón, mientras que el botón B podría ralentizarlo."
    ],
    "STEP_1_TEXT_7": "Código para la interacción con los botones:",
    "STEP_1_TEXT_8": "Esto permitirá una experiencia interactiva donde el usuario controla su 'corazón' virtual.",
    "STEP_1_TITLE_5": "Límites de Velocidad",
    "STEP_1_TEXT_9": [
      "Para evitar ritmos de latido irrealmente rápidos o lentos, estableceremos unos límites para la variable 'beats'.",
      "El corazón no debería poder detenerse completamente ni ir a una velocidad que no pueda ser percibida."
    ],
    "STEP_1_TEXT_10": [
      "Estas restricciones aseguran que el juego se mantiene dentro de unos parámetros lógicos y jugables.",
      "Implementaremos condicionales para asegurar que la variable 'beats' se mantenga dentro del rango deseado."
    ],
    "STEP_1_TITLE_6": "Retroalimentación Visual",
    "STEP_1_TEXT_11": [
      "Además de la animación del corazón, utilizaremos la pantalla de LEDs para mostrar la velocidad actual del latido, u otros indicadores visuales relevantes.",
      "Podríamos mostrar un número que represente los latidos por minuto (BPM)."
    ],
    "STEP_1_TEXT_12": [
      "Esta retroalimentación visual complementa la sonora, haciendo el proyecto más informativo."
    ],
    "STEP_1_TITLE_7": "Cálculo de BPM",
    "STEP_1_TEXT_13": "Para mostrar los latidos por minuto (BPM), tendremos que realizar un pequeño cálculo basándonos en la variable 'beats'.",
    "STEP_1_TEXT_14": "La fórmula para calcular los BPM a partir del tiempo entre latidos (en milisegundos) es: BPM = 60000 / tiempo_entre_latidos.",
    "STEP_1_TITLE_8": "Tabla de Frecuencias Cardíacas",
    "STEP_1_TEXT_15": "Aquí tienes una tabla de referencia para las frecuencias cardíacas, útil para ajustar el ritmo de tu 'corazón' de Micro:bit:",
    "TABLE_TITLE": "Frecuencia Cardíaca (BPM)",
    "TABLE_HD_1": "Latidos por Minuto",
    "TABLE_HD_2": "Tiempo entre Latidos (segundos)",
    "TABLE_HD_3": "Tiempo entre Latidos (milisegundos)",
    "STEP_1_TEXT_16": [
      "Esta tabla te ayudará a entender cómo los valores de 'beats' se correlacionan con un ritmo cardíaco real.",
      "Puedes utilizar estos valores para programar ritmos específicos o para validar tu simulador de latidos."
    ],
    "FORMULA_ALT_TEXT": "Fórmula para calcular la frecuencia de latido del corazón",
    "FORMULA_ALT_TEXT_2": "Imagen representando el sol",
    "FORMULA_ALT_TEXT_3": "Fórmula de la frecuencia cardíaca",
    "STEP_1_TEXT_17": "Esta ilustración muestra la fórmula utilizada para convertir el tiempo entre latidos a latidos por minuto (BPM).",
    "STEP_1_TITLE_9": "Monitorización de la Salud",
    "STEP_1_TEXT_18": [
      "Podríamos añadir una lógica para simular condiciones de salud, donde el corazón cambia de color o emite un sonido de alarma si el ritmo es demasiado alto o bajo.",
      "Esto podría ser un proyecto educativo sobre la salud cardíaca."
    ],
    "STEP_1_TEXT_19": "El código podría cambiar el color del LED o la imagen mostrada si el BPM sale de un rango saludable.",
    "STEP_1_TITLE_10": "Alertas Sonoras y Visuales",
    "STEP_1_TEXT_20": "Implementaremos alertas sonoras y visuales si el ritmo cardíaco simulado entra en zonas de riesgo.",
    "STEP_1_TEXT_21": [
      "Por ejemplo, un sonido agudo y una calavera en la pantalla si el corazón 'se detiene'.",
      "Estas alertas mejoran la accesibilidad y la claridad de la información."
    ],
    "STEP_1_TITLE_11": "Múltiples Pantallas (Opcional)",
    "STEP_1_TEXT_22": "Si tenemos varias Micro:bits, podríamos hacer que una actúe como monitor de corazón y la otra como interfaz de control, comunicándose por radio.",
    "STEP_1_TEXT_23": [
      "Una Micro:bit podría mostrar solo el BPM y la otra la visualización del corazón y los controles.",
      "Esto introduciría el concepto de comunicación inalámbrica entre dispositivos."
    ],
    "STEP_1_TEXT_24": [
      "La comunicación por radio permitiría una mayor complejidad y funcionalidad al proyecto.",
      "Aquí tienes un ejemplo de cómo se podría estructurar el código para esta configuración:"
    ],
    "STEP_1_TEXT_25": [
      "Este código distribuirá las tareas entre dos Micro:bits, simulando un sistema de monitorización remoto."
    ],
    "STEP_1_TITLE_12": "Finalización del Proyecto",
    "STEP_1_TEXT_26": [
      "Una vez todas las funcionalidades estén implementadas, probaremos el proyecto a fondo para asegurarnos de que todo funciona correctamente y que la experiencia de usuario es óptima.",
      "Haremos ajustes hasta que el 'latido' sea perfecto."
    ],
    "STEP_1_TEXT_27": "Asegúrate de que la retroalimentación visual y sonora esté bien sincronizada.",
    "STEP_1_TEXT_28": "¡Tu 'Latido de la Micro:bit' está listo!",
    "STEP_1_TITLE_13": "Personalización Avanzada",
    "STEP_1_TEXT_29": "Experimenta con diferentes animaciones del corazón, sonidos personalizados o añade más sensores para una experiencia aún más inmersiva.",
    "STEP_2_TITLE": "Paso 2: El Código",
    "STEP_2_TEXT": "Descarga el archivo .hex ya compilado para cargarlo directamente a tu Micro:bit.",
    "STEP_3_TITLE": "Paso 3: Evoluciona el Código",
    "STEP_3_TEXT": "Modifica el código para crear un ritmo musical completo, un juego de reacción al ritmo, o conéctalo a otros proyectos!"
  },
  "SECRET_MESSAGE_PAGE": {
    "VIDEO_NOT_SUPPORTED": "Tu navegador no soporta la etiqueta de video.",
    "MORSE_CODE_CAPTION": "Alfabeto de Código Morse",
    "INTRODUCTION_TITLE": "Introducción",
    "INTRODUCTION_TEXT": "Este proyecto te enseña a utilizar la Micro:bit para enviar y recibir mensajes secretos mediante el código Morse.",
    "INTRODUCTION_TEXT_1": "Aprenderás a transformar texto en secuencias de luces y sonidos, y a descifrarlas de nuevo. ¿Preparado para el espionaje digital?",
    "TARGET_TITLE": "Objetivo",
    "TARGET_TEXT": "Crear un comunicador de código Morse funcional utilizando la Micro:bit, capaz de enviar y recibir mensajes de una manera accesible.",
    "MATERIALS_TITLE": "Materiales",
    "MATERIALS_LIST": [
      "2 Micro:bits (para comunicación entre ellas)",
      "Ordenador con conexión USB",
      "Cable USB de datos",
      "Editor de Python"
    ],
    "STEPS_TITLE": "Pasos para la Programación",
    "STEP_1_TITLE": "Paso 1: Preparación del Código Morse",
    "STEP_1_TEXT": "Comenzaremos definiendo el alfabeto de código Morse en Python. Cada letra y número tendrá una representación en puntos (.) y rayas (-).",
    "STEP_1_TEXT_1": "Por ejemplo, la letra 'A' es '.-', la 'B' es '-...' y el '1' es '.----'.",
    "STEP_1_TEXT_2": "Utilizaremos un diccionario para almacenar estas conversiones, lo que facilitará la traducción del texto a código Morse y viceversa.",
    "STEP_1_TEXT_3": "Aquí tienes el fragmento inicial para construir el alfabeto Morse:",
    "STEP_1_TEXT_4": "Este código establece las bases para la codificación y decodificación de nuestros mensajes.",
    "STEP_1_TEXT_5": "También añadiremos las definiciones para los números y algunos signos de puntuación básicos para enriquecer nuestras comunicaciones.",
    "STEP_1_TEXT_6": "Aquí el código completo del alfabeto Morse:",
    "STEP_1_TEXT_7": "Esta es la clave de todo el proyecto de mensajería secreta. Es importante que todos los caracteres que queramos utilizar estén correctamente definidos.",
    "STEP_1_TEXT_8": "Una vez tengamos el diccionario completo, podremos empezar a trabajar en las funciones de codificación y decodificación.",
    "STEP_1_TEXT_9": "Esta primera parte es fundamental para la creación del traductor Morse.",
    "STEP_1_TITLE_2": "Paso 2: Traducción de Texto a Código Morse",
    "STEP_1_TEXT_11": "Ahora crearemos una función que tome un mensaje de texto y lo convierta a su representación en código Morse. La función deberá recorrer cada carácter del mensaje, buscar su equivalente en el diccionario Morse y concatenarlo a una cadena resultante.",
    "STEP_1_TEXT_12": "También tendremos que considerar cómo separar los caracteres y las palabras en código Morse (normalmente con espacios entre caracteres y ' / ' entre palabras).",
    "STEP_1_TEXT_13": "Aquí tienes el código de la función 'text_to_morse':",
    "STEP_1_TEXT_14": "Esta función será el corazón de nuestra capacidad para enviar mensajes secretos.",
    "STEP_1_TEXT_15": "Para probarla, podemos utilizar un mensaje simple como 'HOLA' y ver si la salida es '.... --- .-.. .-'",
    "STEP_1_TEXT_16": "Esta parte es crucial para convertir nuestras palabras en el lenguaje secreto.",
    "STEP_1_TEXT_17": "Asegúrate de probar la función con diferentes tipos de mensajes para verificar su robustez.",
    "STEP_1_TITLE_3": "Paso 3: Envío del Código Morse (Visual y Sonoro)",
    "STEP_1_TEXT_18": "Una vez tengamos el mensaje en código Morse, necesitamos una manera de enviarlo. Para hacerlo accesible, usaremos tanto la pantalla de LEDs de la Micro:bit (visual) como el sonido (auditivo).",
    "STEP_1_TEXT_19": "Una 'raya' (-)' se representará con un LED encendido más largo y un tono de sonido más largo. Un 'punto' ('.') con un LED encendido más corto y un tono de sonido más corto. Un espacio entre caracteres será una pausa breve, y un espacio entre palabras, una pausa más larga.",
    "STEP_1_TEXT_20": "Aquí tienes la función 'send_morse_signal':",
    "STEP_1_TEXT_21": "Esta función hará que nuestra Micro:bit se convierta en un emisor de señales Morse multisensorial.",
    "STEP_1_TEXT_22": "Es importante ajustar los tiempos de duración para los puntos, rayas y pausas para que sean fácilmente distinguibles.",
    "STEP_1_TEXT_23": "La combinación de señales visuales y auditivas mejora significativamente la accesibilidad del proyecto.",
    "STEP_1_TEXT_24": "Esta es la función que transforma el código en una experiencia interactiva.",
    "STEP_1_TITLE_4": "Paso 4: Recepción y Decodificación del Código Morse",
    "STEP_1_TEXT_25": "La parte más desafiante es la recepción. Como la Micro:bit no tiene una entrada de micrófono para detectar sonidos Morse, simularemos la recepción con los botones A y B, o con un sensor de tacto.",
    "STEP_1_TEXT_26": "El botón A puede simular un 'punto' y el botón B una 'raya'. Detectaremos las presiones de los botones y la duración de cada presión para reconstruir el código Morse.",
    "STEP_1_TEXT_27": "También crearemos una función 'morse_to_text' que hará el proceso inverso: tomar una secuencia de código Morse y convertirla de nuevo en texto legible.",
    "STEP_1_TEXT_28": "Aquí tienes el código para la recepción y decodificación:",
    "STEP_1_TEXT_29": "Esta lógica nos permitirá 'leer' los mensajes secretos que envían otras Micro:bits.",
    "STEP_1_TEXT_30": "La función de decodificación utilizará el diccionario Morse inverso para traducir las secuencias de puntos y rayas a letras y palabras.",
    "STEP_1_TEXT_31": "Es crucial gestionar correctamente los tiempos entre las presiones de botones para diferenciar entre puntos, rayas y espacios.",
    "STEP_1_TEXT_32": "Esta parte es la que nos permite descifrar los mensajes.",
    "STEP_1_TITLE_5": "Paso 5: Interacción Completa con Radio (Opcional)",
    "STEP_1_TEXT_33": "Para una experiencia de mensajería secreta completa, dos Micro:bits pueden comunicarse por radio. Una enviaría el código Morse y la otra lo recibiría y lo decodificaría.",
    "STEP_1_TEXT_34": "La Micro:bit emisora utilizaría 'radio.send()' y la receptora 'radio.receive()'. Esto añade un nivel de realismo y funcionalidad al proyecto.",
    "STEP_1_TEXT_35": "Aquí tienes un ejemplo de cómo integrar la radio:",
    "STEP_1_TEXT_36": "Esto permitiría una comunicación inalámbrica entre dispositivos.",
    "STEP_1_TEXT_37": "Es importante asegurarse de que ambas Micro:bits estén configuradas en el mismo grupo de radio y que la velocidad de transmisión sea adecuada.",
    "STEP_1_TEXT_38": "La comunicación por radio abre la puerta a muchas otras aplicaciones.",
    "STEP_1_TITLE_6": "Paso 6: Mejoras de Accesibilidad",
    "STEP_1_TEXT_39": "Para hacer el comunicador Morse aún más accesible, podríamos añadir:",
    "TRANSFORMANT_LIST": [
      "Vibración: Para usuarios con deficiencia auditiva, la Micro:bit podría vibrar en lugar de emitir un sonido.",
      "Pantalla ampliada: Mostrar el mensaje decodificado en una pantalla externa más grande.",
      "Entrada alternativa: Utilizar sensores de movimiento (acelerómetro) para simular puntos y rayas, facilitando el uso a personas con dificultades motrices finas."
    ],
    "STEP_1_TEXT_40": "Estas mejoras garantizarían que el proyecto sea útil para una gama más amplia de usuarios.",
    "STEP_1_TEXT_41": "La implementación de estas funciones requiere una consideración cuidadosa de los diferentes tipos de feedback que se pueden proporcionar.",
    "STEP_1_TEXT_42": "La inclusión desde el diseño es la clave para proyectos exitosos.",
    "STEP_1_TITLE_7": "Paso 7: Depuración y Pruebas",
    "STEP_1_TEXT_43": "Es vital probar cada parte del código de manera independiente y luego de manera conjunta. Envía mensajes de prueba, tanto simples como complejos, para asegurarte de que la codificación, el envío, la recepción y la decodificación funcionan perfectamente.",
    "STEP_1_TEXT_44": "Ajusta los tiempos y las pausas según sea necesario para optimizar la claridad de las señales.",
    "STEP_1_TEXT_45": "La depuración es un proceso iterativo que asegura la calidad de tu comunicador Morse.",
    "STEP_1_TITLE_8": "Paso 8: Código Completo",
    "STEP_1_TEXT_46": "Aquí tienes el código completo del proyecto 'Mensaje Secreto' para la Micro:bit.",
    "STEP_1_TEXT_47": "Este código integra todas las funcionalidades descritas en los pasos anteriores, desde la definición del alfabeto Morse hasta el envío y la recepción de mensajes.",
    "STEP_1_TEXT_48": "Está diseñado para ser un punto de partida para experimentos y personalizaciones futuras.",
    "STEP_1_TITLE_9": "Paso 9: Descargar el Archivo .hex",
    "STEP_1_TEXT_49": "Si no quieres programarlo tú mismo, puedes descargar el archivo .hex ya compilado para cargarlo directamente a tu Micro:bit.",
    "STEP_1_TEXT_50": "Este archivo contiene el código del juego 'Mensaje Secreto' listo para usar. Solo tienes que conectar la Micro:bit al ordenador y arrastrar el archivo .hex a la unidad que aparece.",
    "STEP_1_TEXT_51": "Esto te permitirá probar el proyecto inmediatamente.",
    "STEP_2_TITLE": "Paso 10: Evoluciona el Código",
    "STEP_2_TEXT": "Modifica el código para crear un cifrado más complejo, añadir nuevos métodos de entrada/salida, o integrarlo con otros proyectos de comunicación."
  },
  "RPS_PAGE": {
    "TITLE": "Piedra, Papel, Tijera",
    "VIDEO_NOT_SUPPORTED": "Tu navegador no soporta la etiqueta de video.",
    "INTRODUCTION_TITLE": "Introducción",
    "INTRODUCTION_TEXT": "Este proyecto te enseña a crear el clásico juego de 'Piedra, Papel, Tijera' en tu Micro:bit. ¡Prepárate para enfrentarte a la inteligencia artificial!",
    "INTRODUCTION_TEXT_1": "Aprenderás a utilizar la pantalla de LEDs para mostrar las opciones (piedra, papel o tijera) y los botones para hacer tu elección. También incorporaremos un generador de números aleatorios para la decisión de la Micro:bit.",
    "MATERIALS_TITLE": "Materiales",
    "MATERIALS_LIST": [
      "1 Micro:bit",
      "Ordenador con conexión USB",
      "Cable USB de datos",
      "Editor de Python"
    ],
    "TARGET_TITLE": "Objetivo",
    "TARGET_TEXT": "Crear un juego de 'Piedra, Papel, Tijera' accesible y funcional con la Micro:bit, utilizando señales visuales y auditivas para la interacción.",
    "STEPS_TITLE": "Pasos para la Programación",
    "STEP_1_TITLE": "Paso 1: Configuración Inicial y Elección del Jugador",
    "STEP_1_TITLE_2": "Importaciones necesarias",
    "STEP_1_TEXT_1": "Primero, importaremos los módulos necesarios para el funcionamiento de la Micro:bit y la generación de números aleatorios.",
    "IMPORTS_LIST": [
      "import microbit",
      "import random"
    ],
    "STEP_1_TEXT_2": "Estas líneas nos permitirán interactuar con los componentes de la Micro:bit y obtener resultados aleatorios.",
    "STEP_1_TITLE_3": "Elección del jugador con botones",
    "STEP_1_TEXT_3": "El jugador hará su elección pulsando los botones A o B. El botón A puede ser 'Piedra' y el botón B puede ser 'Papel'. La 'Tijera' la elegiremos si se pulsan ambos botones.",
    "STEP_1_TEXT_4": "Implementaremos una función que detecte qué botones se pulsan y asigne un valor numérico (0 para Piedra, 1 para Papel, 2 para Tijera).",
    "STEP_1_TITLE_4": "Definición de las figuras",
    "STEP_1_TEXT_5": "Definiremos las imágenes que representarán la piedra, el papel y la tijera en la pantalla LED de la Micro:bit. Utilizaremos la matriz de LEDs para dibujarlas de forma sencilla.",
    "STEP_1_TEXT_6": "Aquí tienes cómo definir las imágenes:",
    "CODE_1_LIST": [
      "pedra = microbit.Image.SQUARE",
      "paper = microbit.Image.CHESSBOARD",
      "tisora = microbit.Image.SCISSORS"
    ],
    "STEP_1_TEXT_7": "Estas imágenes harán el juego más visual e intuitivo.",
    "STEP_1_TITLE_5": "Lógica del juego: elección de la Micro:bit",
    "STEP_1_TEXT_8": "La Micro:bit deberá hacer su propia elección de forma aleatoria. Utilizaremos la función 'random.randint(0, 2)' para obtener un número entre 0 y 2, que representarán la piedra, el papel o la tijera.",
    "STEP_1_TEXT_9": "Esta elección se hará cada vez que el jugador haga su elección, asegurando que el juego sea impredecible.",
    "STEP_1_TEXT_10": "Aquí tienes el código para la elección de la Micro:bit:",
    "STEP_1_TEXT_11": "Esta parte es crucial para la interactividad del juego.",
    "STEP_1_TITLE_6": "Determinar el ganador",
    "STEP_1_TEXT_12": "Ahora implementaremos la lógica para determinar quién gana la ronda. Recordamos las reglas: Piedra gana a Tijera, Tijera gana a Papel, y Papel gana a Piedra.",
    "STEP_1_TEXT_13": "Utilizaremos una serie de condicionales (if/elif/else) para comparar las elecciones del jugador y de la Micro:bit.",
    "STEP_1_TEXT_14": "Aquí tienes la función 'determine_winner':",
    "STEP_1_TITLE_7": "Mostrar el resultado",
    "STEP_1_TEXT_15": "Una vez determinado el ganador, mostraremos el resultado en la pantalla LED de la Micro:bit. Podemos utilizar iconos (por ejemplo, una cara feliz para ganar, una triste para perder, y una neutra para empatar).",
    "STEP_1_TEXT_16": "Además del icono, podemos hacer que la Micro:bit emita un sonido diferente para cada resultado, mejorando la accesibilidad para usuarios con dificultades visuales.",
    "STEP_1_TITLE_8": "Bucle principal del juego",
    "STEP_1_TEXT_17": "El juego se repetirá continuamente hasta que el usuario decida detenerlo. Utilizaremos un bucle 'while True' para mantener el juego activo.",
    "STEP_1_TEXT_18": "Dentro del bucle, esperaremos la entrada del jugador, haremos la elección de la Micro:bit, determinaremos el ganador y mostraremos el resultado.",
    "STEP_1_TEXT_19": "Aquí tienes la estructura básica del bucle principal:",
    "STEP_1_TITLE_9": "Retroalimentación multisensorial",
    "STEP_1_TEXT_20": "Para mejorar la accesibilidad, añadiremos sonidos para cada acción y resultado. Por ejemplo, un sonido corto al elegir una opción, un sonido de victoria, uno de derrota y uno de empate.",
    "STEP_1_TEXT_21": "Utilizaremos el módulo 'music' para reproducir melodías sencillas.",
    "STEP_1_TEXT_22": "Esto permitirá que los usuarios con discapacidad visual puedan disfrutar plenamente del juego.",
    "STEP_1_TITLE_10": "Implementación del sonido",
    "STEP_1_TEXT_23": "Integraremos las funciones de sonido en la lógica del juego. Por ejemplo, cuando el jugador gane, la melodía de victoria se reproducirá, y así sucesivamente.",
    "STEP_1_TEXT_24": "Es importante que los sonidos sean distintivos y fáciles de reconocer.",
    "STEP_1_TEXT_25": "Esta adición aumentará significativamente la inmersión y la accesibilidad del juego.",
    "STEP_1_TITLE_11": "Detección de gestos (Opcional)",
    "STEP_1_TEXT_26": "Como alternativa a los botones, podríamos utilizar el acelerómetro de la Micro:bit para detectar gestos. Por ejemplo, sacudir la Micro:bit podría significar una elección aleatoria, o inclinarla hacia un lado para elegir piedra, papel o tijera.",
    "STEP_1_TEXT_27": "Esto ofrece una opción de entrada más accesible para usuarios con dificultades motrices.",
    "STEP_1_TITLE_12": "Código completo con gestos",
    "STEP_1_TEXT_28": "Aquí tienes un ejemplo de cómo podríamos integrar la detección de gestos en nuestro juego 'Piedra, Papel, Tijera':",
    "STEP_1_TEXT_29": "Este código sustituye o complementa las entradas de los botones por gestos.",
    "STEP_1_TEXT_30": "La función 'gest_detection' sería responsable de leer el acelerómetro y traducir los movimientos en elecciones de juego.",
    "STEP_1_TEXT_31": "Esta funcionalidad haría el juego más versátil y adaptable a diferentes necesidades.",
    "STEP_1_TEXT_32": "Así es como las adaptaciones pueden mejorar la experiencia de juego para todos.",
    "STEP_1_TEXT_33": "Consideraremos la implementación de una función 'on_shake' para detectar el movimiento de la Micro:bit.",
    "STEP_1_TEXT_34": "Esta función devolvería una de las tres opciones (Piedra, Papel o Tijera) de forma aleatoria o basada en la intensidad de la sacudida.",
    "STEP_1_TEXT_35": "El uso del acelerómetro permite una interacción más dinámica y menos dependiente de los controles físicos.",
    "STEP_1_TEXT_36": "Esta es una gran adición para la inclusión de todos los jugadores.",
    "STEP_1_TITLE_13": "Comunicación con otra Micro:bit (Multijugador)",
    "STEP_1_TEXT_37": "Para jugar contra un amigo, podemos hacer que dos Micro:bits se comuniquen por radio. Cada jugador haría su elección en su Micro:bit, y esta enviaría su elección a la otra Micro:bit.",
    "STEP_1_TEXT_38": "La Micro:bit receptora compararía las dos elecciones y mostraría el resultado.",
    "STEP_1_TEXT_39": "Esto abre la puerta a un modo multijugador interactivo y accesible.",
    "STEP_1_TITLE_14": "Implementación del multijugador",
    "STEP_1_TEXT_40": "Aquí tienes cómo podríamos modificar el código para permitir el modo multijugador vía radio:",
    "STEP_1_TEXT_41": "Una Micro:bit enviaría un mensaje con su elección y la otra recibiría el mensaje y haría la comparación.",
    "STEP_1_TEXT_42": "Es importante configurar el mismo grupo de radio en ambas Micro:bits.",
    "STEP_1_TEXT_43": "La comunicación por radio es una herramienta potente para la creación de juegos interactivos.",
    "STEP_1_TEXT_44": "Esta es la clave para jugar con amigos y familiares.",
    "STEP_1_TITLE_15": "Mejoras en la interfaz de usuario",
    "STEP_1_TEXT_45": "Para hacer la interfaz de usuario más clara y accesible, podríamos:",
    "STEP_1_TEXT_46": "Mostrar animaciones más elaboradas para la piedra, el papel y la tijera.",
    "STEP_1_TEXT_47": "Utilizar diferentes tonos de sonido para cada elección del jugador (Piedra, Papel, Tijera).",
    "STEP_1_TEXT_48": "Esto haría la experiencia más rica y visualmente atractiva.",
    "STEP_1_TITLE_16": "Puntuación y rondas",
    "STEP_1_TEXT_49": "Podríamos añadir un sistema de puntuación para llevar un registro de quién gana más rondas. También se podrían implementar múltiples rondas, y el juego finalizaría cuando un jugador llegara a una puntuación predeterminada.",
    "STEP_1_TEXT_50": "Esto aumentaría la rejugabilidad y la competitividad del juego.",
    "STEP_1_TEXT_51": "La puntuación visible en la Micro:bit podría motivar a los jugadores.",
    "STEP_1_TITLE_17": "Código para la puntuación",
    "STEP_1_TEXT_52": "Aquí tienes cómo podríamos implementar la puntuación en nuestro juego:",
    "STEP_1_TEXT_53": "Las variables 'player_score' y 'microbit_score' se podrían actualizar después de cada ronda.",
    "STEP_1_TITLE_18": "Finalización del juego",
    "STEP_1_TEXT_54": "Una vez se hayan jugado un número determinado de rondas, el juego debería anunciar un ganador final. Podríamos hacer que la Micro:bit muestre un mensaje de '¡HAS GANADO!' o '¡HAS PERDIDO!' con una animación.",
    "STEP_1_TEXT_55": "También se podría reproducir una melodía final diferente para cada resultado.",
    "STEP_1_TEXT_56": "Esto proporciona un final satisfactorio al juego.",
    "STEP_1_TITLE_19": "Código de finalización",
    "STEP_1_TEXT_57": "Aquí tienes un ejemplo de cómo gestionar la finalización del juego:",
    "STEP_1_TEXT_58": "Esta lógica asegura que el juego tenga un principio y un final claros.",
    "STEP_1_TITLE_20": "Depuración y pruebas",
    "STEP_1_TEXT_59": "Como con cualquier proyecto de programación, es esencial depurar y probar el juego a fondo. Asegúrate de que todas las reglas funcionan correctamente, que los sonidos y las animaciones se reproducen como se espera, y que la interacción con el usuario es fluida.",
    "STEP_1_TEXT_60": "La depuración regular garantiza un juego de calidad.",
    "STEP_2_TITLE": "Paso 2: El Código Completo",
    "STEP_2_TEXT": "Si no quieres programarlo tú mismo, puedes descargar el archivo .hex ya compilado para cargarlo directamente a tu Micro:bit.",
    "STEP_3_TITLE": "Paso 3: Evoluciona el Código",
    "STEP_3_TEXT": "Modifica el código para crear nuevas opciones de juego, añadir un modo multijugador más avanzado, o integrarlo con otros proyectos de la Micro:bit."
  },
  "COUNTDOWN_PAGE": {
    "TITLE": "La Cuenta Atrás Final",
    "VIDEO_NOT_SUPPORTED": "Tu navegador no soporta la etiqueta de video.",
    "INTRODUCTION_H2": "Introducción",
    "INTRODUCTION_P": [
      "Este proyecto es la programación de una cuenta atrás desde 10 hasta 0. La cuenta atrás se mostrará en la pantalla de la Micro:bit y estará acompañada de una pulsación, la misma que se hizo en el proyecto 'El latido de la Micro:bit', para tener una estimulación sonora además de una visual.",
      "En el proyecto se verá un nuevo tipo de bucle, un bucle for, y se verá cómo declarar una variable que utilizaremos para realizar la cuenta atrás.",
      "¡Empecemos la cuenta atrás!"
    ],
    "MATERIALS_H2": "Materiales",
    "MATERIAL_MICROBIT": "1 Micro:bit.",
    "MATERIAL_ITEM_1": "Portátil.",
    "MATERIAL_ITEM_2": "Cable USB-A",
    "MATERIAL_ITEM_3": "Editor de Python.",
    "STEPS_H2": "Pasos",
    "STEP_1_H3": "Paso 1: Desarrollando el Código",
    "STEP_1_H4": "Declarando una variable",
    "STEP_1_P": [
      "El código de la cuenta atrás es, posiblemente, más sencillo que el código del proyecto anterior, aunque también tiene sus peculiaridades. La primera es la declaración de una variable.",
      "Cuando hablamos de variables, debemos saber distinguir entre una variable de ámbito global y una de ámbito local. Por el momento, lo único que hay que saber es que las variables de ámbito global, como la que utilizaremos en este proyecto, se declaran justo después de la línea de los imports y se hace de la siguiente manera:"
    ],
    "STEP_1_P_2": "[nombre variable] = [valor variable]",
    "STEP_1_P_3": "Un ejemplo de declaración sería:",
    "STEP_1_P_4": "Dicho esto, justo al inicio de nuestro proyecto escribiremos:",
    "STEP_1_P_5": "En la línea 6 realizamos la declaración de la variable i y su valor: 10.",
    "STEP_1_H4_1": "Bucle for",
    "STEP_1_P_6": "Después de la declaración de la variable iniciamos el bucle for, que es el bucle principal del proyecto.",
    "STEP_1_H4_2": "Explicación del código",
    "STEP_1_P_7": [
      "En este proyecto debemos explicar el bucle for. Un bucle for se ejecuta un determinado número de veces. Para decidir cuántas veces se ejecuta un bucle for se tiende a incluir un algoritmo que modifica el valor de la variable que controla el bucle cada vez que se ejecuta el bucle. En este caso se modifica el valor de la variable step.",
      "En la línea 9 declaramos el bucle for y establecemos que se ejecutará 11 veces (index in range(11)). Expliquemos un poco más esta última sentencia:",
      "index: Es el valor que se irá modificando.",
      "in; vincular index con su rango de valores.",
      "range(): Indica el rango de valores, o los pasos a realizar por el bucle.",
      "11: Es el número de veces (pasos) que se ejecutará el bucle for."
    ],
    "STEP_1_P_8": [
      "Las líneas 10 y 11 ya las conocemos del proyecto anterior. En la línea 12 lo que estamos haciendo es reducir en un valor la variable i cada vez que se ejecuta el bucle for.",
      "Por último, en la línea 13 hacemos que el código se detenga 1 segundo antes de volverse a ejecutar el bucle for."
    ],
    "STEP_1_H4_3": "Concepto",
    "STEP_1_P_9": [
      "¿No ha llamado la atención algo del código? ¿Os habéis fijado en que el valor de la variable i es de 10 y ejecutamos el bucle for 11 veces? Esta “incoherencia” se debe a que el 0 es un número y por lo tanto se debe tener en cuenta a la hora de programar. Si hacemos que el bucle for se ejecute solo 10 veces el último número que alcanzará la variable i será 1 y no 0.",
      "¡Haz la prueba!"
    ],
    "STEP_2_H3": "Paso 2: El código",
    "STEP_2_P": "Descarga del archivo hex.",
    "STEP_3_H3": "Paso 3: Evoluciona el código",
    "STEP_3_P": "Modifica el código añadiendo una animación final, o empleando la cuenta atrás para iniciar algún proceso en la Micro:bit. ¡Esta cuenta atrás puede ser la primera piedra de un proyecto más grande!'"
  },
  "SETTINGS": {
    "TITLE": "Configuración",
    "DESCRIPTION": "Aquí puedes ajustar las configuraciones de la aplicación.",
    "THEME_TITLE": "Apariencia",
    "DARK_MODE": "Modo Oscuro",
    "DARK_MODE_TOGGLE": "Modo Oscuro",
    "FONT_FAMILY_SELECT": "Tipo de Letra",
    "FONT_SIZE_SELECT": "Tamaño de Letra",
    "FONT_SIZE_SMALL": "Pequeño",
    "FONT_SIZE_MEDIUM": "Mediano",
    "FONT_SIZE_LARGE": "Grande",
    "ANIMATIONS_TOGGLE": "Desactivar Animaciones",
    "LANGUAGE_SELECT": "Idioma"
  },
  "ACCESSIBLE_PROGRAMMING": {
    "TITLE": "Programación Accesible",
    "H1": "Programación Accesible con Micro:bit",
    "INTRO_P1": "La programación con Micro:bit ofrece una excelente oportunidad para introducir a personas de todas las edades y habilidades en el mundo de la tecnología. Sin embargo, para asegurar que sea verdaderamente inclusiva, es fundamental considerar la accesibilidad desde la fase de diseño de los proyectos.",
    "INTRO_P2": "La accesibilidad no puede ser un parche que se añade al final del proyecto para intentar cumplir con un requisito u obtener beneficios.",
    "CREATION_TITLE": "Creación de Proyectos Accesibles para Micro:bit",
    "CREATION_P1": "Para crear proyectos accesibles con Micro:bit, es importante tener en cuenta varios aspectos:",
    "CREATION_LI1_TITLE": "Feedback Multisensorial:",
    "CREATION_LI1_TEXT": "Utilizar no solo la pantalla de LEDs, sino también el sonido (si el modelo de Micro:bit lo permite o se conecta a un altavoz) para proporcionar información. Por ejemplo, un juego puede emitir un sonido al acertar y otro diferente al fallar.",
    "CREATION_LI2_TITLE": "Entradas Alternativas:",
    "CREATION_LI2_TEXT": "Considerar opciones más allá de los botones A y B. Los pines de la Micro:bit pueden conectarse a sensores externos o pulsadores adaptados, facilitando la interacción para personas con movilidad reducida. Otra opción es utilizar el acelerómetro de la Micro:bit.",
    "CREATION_LI3_TITLE": "Claridad y Simplicidad:",
    "CREATION_LI3_TEXT": "Mantener los programas tan simples y claros como sea posible. Evitar secuencias de acciones complejas que puedan confundir a usuarios con dificultades cognitivas o de memoria.",
    "CREATION_LI4_TITLE": "Documentación Clara:",
    "CREATION_LI4_TEXT": "Proporcionar instrucciones detalladas y fáciles de entender, idealmente en múltiples formatos (texto, audio, pictogramas).",
    "BLOCKLY_TITLE": "Programación por Bloques (Blockly) y Discapacidad",
    "BLOCKLY_P1": "Las interfaces de programación por bloques, como la que utiliza MakeCode para Micro:bit, son una herramienta potente para la accesibilidad. Su naturaleza visual e intuitiva reduce barreras importantes:",
    "BLOCKLY_OVERCOME_TITLE": "Barreras que Supera:",
    "BLOCKLY_OVERCOME_LI1_TITLE": "Discapacidad visual (baja visión):",
    "BLOCKLY_OVERCOME_LI1_TEXT": "Aunque las interfaces visuales pueden ser un reto, el uso de bloques con códigos de color permite que los usuarios con baja visión reconozcan el tipo de bloque que se está utilizando de manera más rápida y sencilla.",
    "BLOCKLY_OVERCOME_LI2_TITLE": "Discapacidad motriz:",
    "BLOCKLY_OVERCOME_LI2_TEXT": "La manipulación de bloques suele ser más sencilla que la escritura de código, especialmente con adaptaciones de ratón o teclado. La función de arrastrar y soltar puede ser reemplazada por la navegación con teclado para quienes no pueden usar un ratón.",
    "BLOCKLY_OVERCOME_LI3_TITLE": "Discapacidad cognitiva y del aprendizaje:",
    "BLOCKLY_OVERCOME_LI3_TEXT": "La representación visual del código reduce la carga cognitiva, al no requerir la memorización de sintaxis complejas. Los bloques guían al usuario en la estructura lógica del programa.",
    "BLOCKLY_CHALLENGES_TITLE": "Desafíos Actuales:",
    "BLOCKLY_CHALLENGES_LI1_TITLE": "Lectores de Pantalla:",
    "BLOCKLY_CHALLENGES_LI1_TEXT": "A menudo, las interfaces de arrastrar y soltar no son completamente compatibles con los lectores de pantalla, lo que dificulta la interacción para personas ciegas o con baja visión severa.",
    "BLOCKLY_CHALLENGES_LI2_TITLE": "Navegación por Teclado:",
    "BLOCKLY_CHALLENGES_LI2_TEXT": "La navegación completa y eficiente solo con teclado no siempre está implementada a la perfección en todas las plataformas de programación por bloques.",
    "BLOCKLY_CHALLENGES_LI3_TITLE": "Personalización:",
    "BLOCKLY_CHALLENGES_LI3_TEXT": "La falta de opciones de personalización (tamaño de fuente, contraste de color, eliminación de animaciones) puede afectar a usuarios con diversas necesidades visuales o cognitivas.",
    "BLOCKLY_CHALLENGES_LI4_TITLE": "Documentación y Ejemplos:",
    "BLOCKLY_CHALLENGES_LI4_TEXT": "No siempre se dispone de documentación y ejemplos de proyectos diseñados específicamente con la accesibilidad en mente.",
    "PYTHON_TITLE": "Programación por Código (Editor Micro:bit Python)",
    "PYTHON_P1": "Como alternativa a la programación por bloques se puede utilizar la programación por código (microPython o JavaScript). Este tipo de programación, al ser texto plano, es altamente accesible para los lectores de pantalla.",
    "PYTHON_P2": "El problema de este tipo de programación es que los usuarios deben tener un conocimiento mínimo del lenguaje de programación, por lo que se les tiene que enseñar el lenguaje y los conceptos al mismo tiempo. Esto no sucede con la programación por bloques, ya que el conocimiento del lenguaje no es necesario y los conceptos principales que se trabajan son los conceptos de programación como variables, constantes, bucles, etc.",
    "PYTHON_P3": "El único procedimiento que existe actualmente para minimizar esta barrera (conocimiento del lenguaje) es la creación de bloques de programación donde el alumno solo debe reemplazar o completar una parte del código. La creación del esqueleto de los bloques de programación en código sería la única opción actual para garantizar un acceso del 100% mediante un lector de pantalla.",
    "PYTHON_P4": "Fomentar la programación accesible no solo beneficia a las personas con discapacidad, sino que también mejora la experiencia para todos los usuarios, promoviendo una cultura de diseño inclusivo en el ámbito de la tecnología.",
    "PYTHON_P5": "A continuación se muestran dos ejemplos, un ejemplo donde la respuesta de la Micro:bit solo se realiza a través de la pantalla y otro, más accesible, donde la salida de información se realiza a través de la pantalla y se refuerza con una salida de sonido.",
    "MODAL_NON_ACCESSIBLE_TITLE": "Ejemplo no Accesible",
    "MODAL_CLOSE": "Cerrar",
    "MODAL_NON_ACCESSIBLE_H2": "Videoclip (No Accesible)",
    "MODAL_NON_ACCESSIBLE_P": "El videoclip del ejemplo no accesible iría aquí.",
    "MODAL_VIEW_CODE": "Ver Código",
    "MODAL_ACCESSIBLE_TITLE": "Ejemplo Accesible",
    "MODAL_ACCESSIBLE_H2": "Videoclip (Accesible)",
    "MODAL_ACCESSIBLE_P": "Placa Micro:bit con un corazón latiendo y emitiendo un sonido (pip) con cada latido del corazón.",
    "MODAL_CODE_TITLE": "Código",
    "NON_ACCESSIBLE_EXAMPLE_BUTTON": "Ejemplo no accesible",
    "ACCESSIBLE_EXAMPLE_BUTTON": "Ejemplo accesible"
  },
  "ACCESSIBILITY_EVALUATOR_TITLE": "Evaluador de accesibilidad",
  "COMPROBAR_ACCESIBILIDAD_TITLE": "Comprobar Accesibilidad (Automática)",
  "COMPROBAR_ACCESIBILIDAD_MANUAL_TITLE": "Comprobar Accesibilidad (Manual)",
  "MICROPYTHON_PAGE": {
    "H1": "Curso de Programación en MicroPython para Micro:bit (Énfasis en Accesibilidad)",
    "H2_INTRO": "Introducción a MicroPython y Micro:bit",
    "P_INTRO": "Este curso te introducirá al emocionante mundo de la programación con MicroPython en la placa Micro:bit. Aprenderás a crear proyectos interactivos, con un enfoque especial en cómo hacerlos accesibles para todos los usuarios, independientemente de sus capacidades. La Micro:bit es una pequeña computadora programable diseñada para hacer que el aprendizaje de la programación sea divertido y accesible. Con MicroPython, un dialecto optimizado de Python para microcontroladores, podrás escribir código de manera sencilla y eficiente.",
    "H2_MODULE1": "Módulo 1: Primeros Pasos y Salidas Accesibles",
    "H3_MODULE1_BASIC": "Conceptos Básicos de MicroPython",
    "P_MODULE1_BASIC": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore y dolore magna aliqua. Ut enim ad minim veniam, quis nostrud ejercicio ullamco laboris nisi ut aliquip ex ea commodo consequat.",
    "H3_MODULE1_LED": "Mostrando Texto en la Pantalla LED (con consideraciones de Accesibilidad)",
    "P_MODULE1_LED": "Aprenderemos a usar la matriz de LEDs de la Micro:bit para mostrar mensajes. Es crucial considerar que los usuarios con discapacidad visual podrían no percibir esta salida. Más adelante, exploraremos métodos alternativos para comunicar la información.",
    "H2_MODULE2": "Módulo 2: Entradas Interactivas y Retroalimentación Multisensorial",
    "H3_MODULE2_INPUTS": "Uso de Botones y Entradas Digitales",
    "P_MODULE2_INPUTS": "Exploraremos cómo los botones A y B, así como las entradas digitales, pueden ser utilizados para interactuar con nuestros programas. Para la accesibilidad, consideraremos cómo estas entradas pueden ser adaptadas o complementadas.",
    "H3_MODULE2_SOUND": "Integrando Sonido para Retroalimentación",
    "P_MODULE2_SOUND": "La retroalimentación auditiva es fundamental para la accesibilidad. Aprenderemos a usar el zumbador (o altavoz externo) para proporcionar sonidos que refuercen la información visual o la sustituyan completamente para usuarios con discapacidad visual. Por ejemplo, si un juego requiere que el usuario presione un botón, una combinación de una flecha visual en la pantalla LED y un sonido distintivo al presionar el botón puede mejorar significativamente la experiencia para todos.",
    "H2_MODULE3": "Módulo 3: Sensores y Adaptaciones para Diversidad Funcional",
    "H3_MODULE3_SENSORS": "Lectura de Sensores (Acelerómetro, Brújula, Temperatura)",
    "P_MODULE3_SENSORS": "La Micro:bit cuenta con varios sensores incorporados que nos permiten interactuar con el entorno. Aprenderemos a leer datos del acelerómetro (para detectar movimiento), la brújula (para la orientación) y el sensor de temperatura.",
    "H3_MODULE3_ADAPTATIONS": "Adaptaciones de Sensores para Accesibilidad",
    "P_MODULE3_ADAPTATIONS": "Analizaremos cómo los datos de los sensores pueden ser utilizados para crear interacciones alternativas. Por ejemplo, un programa que se activa al inclinar la Micro:bit podría ser más accesible para personas con movilidad reducida que un botón tradicional. Además, veremos cómo la información obtenida de los sensores puede ser traducida a salidas multisensoriales (visual, auditiva, táctil).",
    "H2_CONCLUSIONS": "Conclusiones y Próximos Pasos",
    "P_CONCLUSIONS": "Este curso ha cubierto las bases de la programación en MicroPython con un fuerte énfasis en el diseño accesible. Recuerda que la accesibilidad no es una característica adicional, sino un principio fundamental para crear tecnología inclusiva. ¡Anímate a explorar más proyectos y a seguir aprendiendo cómo hacer la tecnología accesible para todos!"
  },
  "REPOSITORIO_PAGE": {
    "CONTENT": "Contenido de la página Repositorio.",
    "HEADER": {
      "HOME": "Inicio",
      "REPOSITORY": "Repositorio",
      "DOCUMENTATION": "Documentación",
      "COMMUNITY": "Comunidad"
    },
    "HERO": {
      "TITLE": "Repositorio de Proyectos Accesibles",
      "SUBTITLE": "Explora, comparte y aprende con proyectos de Micro:bit diseñados con accesibilidad en mente",
      "UPLOAD_PROJECT_BUTTON": "Subir tu Proyecto"
    },
    "STATS": {
      "PROJECTS_PUBLISHED": "Proyectos publicados",
      "TOTAL_DOWNLOADS": "Descargas totales",
      "CONTRIBUTORS": "Colaboradores",
      "CATEGORIES": "Categorías"
    },
    "FILTERS": {
      "LABEL": "Filtrar por:",
      "ALL": "Todos",
      "SEARCH_PLACEHOLDER": "Buscar proyectos..."
    },
    "CATEGORIES": {
      "ACCESSIBILITY": "Accesibilidad",
      "SENSORS": "Sensores",
      "COMMUNICATION": "Comunicación",
      "EDUCATION": "Educación",
      "ENTERTAINMENT": "Entretenimiento"
    },
    "PROJECTS_GRID": {
      "EMPTY_STATE_TITLE": "No se encontraron proyectos",
      "EMPTY_STATE_SUBTITLE": "Intenta con otros filtros o sé el primero en subir un proyecto"
    },
    "UPLOAD_MODAL": {
      "TITLE": "Subir Nuevo Proyecto",
      "SUBTITLE": "Comparte tu proyecto accesible con la comunidad",
      "PROJECT_TITLE_LABEL": "Título del proyecto *",
      "PROJECT_TITLE_PLACEHOLDER": "Ej: Semáforo sonoro accesible",
      "CATEGORY_LABEL": "Categoría *",
      "SELECT_CATEGORY_PLACEHOLDER": "Selecciona una categoría",
      "DESCRIPTION_LABEL": "Descripción *",
      "DESCRIPTION_PLACEHOLDER": "Describe tu proyecto, qué hace y cómo ayuda a la accesibilidad...",
      "AUTHOR_NAME_LABEL": "Tu nombre *",
      "AUTHOR_NAME_PLACEHOLDER": "Ej: María García",
      "TAGS_LABEL": "Etiquetas (presiona Enter para agregar)",
      "TAGS_PLACEHOLDER": "Ej: sonido, LED, vibración...",
      "CODE_LABEL": "Código del proyecto (.py) *",
      "DRAG_FILE_TEXT_BOLD": "Arrastra tu archivo .py aquí",
      "CLICK_TO_SELECT_TEXT": "o haz clic para seleccionar",
      "PUBLISH_BUTTON": "Publicar Proyecto",
      "LEVEL_LABEL": "Nivel",
      "SELECT_LEVEL_PLACEHOLDER": "Selecciona un nivel",
      "MATERIALS_LABEL": "Materiales"
    },
    "LEVELS": {
      "LOW": "Bajo",
      "MEDIUM": "Medio",
      "HIGH": "Alto"
    },
    "DETAIL_MODAL": {
      "DESCRIPTION_SECTION_TITLE": "Descripción",
      "TAGS_SECTION_TITLE": "Etiquetas",
      "CODE_SECTION_TITLE": "Código del proyecto",
      "COPY_CODE_BUTTON": "Copiar",
      "COPIED_CODE_BUTTON": "✓ Copiado",
      "DOWNLOAD_FULL_PROJECT_BUTTON": "Descargar proyecto completo"
    },
    "PROJECT_CARD": {
      "DOWNLOAD_BUTTON": "Descargar",
      "VIEW_CODE_BUTTON": "Ver código"
    },
    "TOAST": {
      "PROJECT_PUBLISHED_SUCCESS": "¡Proyecto publicado con éxito! 🎉"
    }
  },
  "TAG_CATEGORIES": {
    "GENERAL": "General",
    "MICROBIT": "Micro:bit",
    "ACCESSIBILITY": "Accesibilidad",
    "LANGUAGES": "Lenguajes",
    "CONNECTIVITY": "Conectividad"
  },
  "TAGS": {
    "EDUCATION": "Educación",
    "GAME": "Juego",
    "TOOL": "Herramienta",
    "SCIENCE": "Ciencia",
    "ART": "Arte",
    "MUSIC": "Música",
    "SPORT": "Deporte",
    "LED": "LED",
    "RADIO": "Radio",
    "PINS": "Pines",
    "SENSORS": "Sensores",
    "BUTTONS": "Botones",
    "ACCELEROMETER": "Acelerómetro",
    "COMPASS": "Brújula",
    "VISUAL": "Visual",
    "AUDITORY": "Auditiva",
    "MOTOR": "Motriz",
    "COGNITIVE": "Cognitiva",
    "EASY_READING": "Lectura Fácil",
    "AAC": "CAA",
    "MICROPYTHON": "MicroPython",
    "MAKECODE": "MakeCode",
    "SCRATCH": "Scratch",
    "BLUETOOTH": "Bluetooth",
    "IOT": "IoT",
    "NETWORKS": "Redes"
  },
  "ACCESSIBILITY_EVALUATOR_TITLE": "Evaluador de accesibilidad",
  "COMPROBAR_ACCESIBILIDAD_TITLE": "Comprobar Accesibilidad (Automática)",
  "COMPROBAR_ACCESIBILIDAD_MANUAL_TITLE": "Comprobar Accesibilidad (Manual)",
  "MICROPYTHON_PAGE": {
    "H1": "Curso de Programación en MicroPython para Micro:bit (Énfasis en Accesibilidad)",
    "H2_INTRO": "Introducción a MicroPython y Micro:bit",
    "P_INTRO": "Este curso te introducirá al emocionante mundo de la programación con MicroPython en la placa Micro:bit. Aprenderás a crear proyectos interactivos, con un enfoque especial en cómo hacerlos accesibles para todos los usuarios, independientemente de sus capacidades. La Micro:bit es una pequeña computadora programable diseñada para hacer que el aprendizaje de la programación sea divertido y accesible. Con MicroPython, un dialecto optimizado de Python para microcontroladores, podrás escribir código de manera sencilla y eficiente.",
    "H2_MODULE1": "Módulo 1: Primeros Pasos y Salidas Accesibles",
    "H3_MODULE1_BASIC": "Conceptos Básicos de MicroPython",
    "P_MODULE1_BASIC": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore y dolore magna aliqua. Ut enim ad minim veniam, quis nostrud ejercicio ullamco laboris nisi ut aliquip ex ea commodo consequat.",
    "H3_MODULE1_LED": "Mostrando Texto en la Pantalla LED (con consideraciones de Accesibilidad)",
    "P_MODULE1_LED": "Aprenderemos a usar la matriz de LEDs de la Micro:bit para mostrar mensajes. Es crucial considerar que los usuarios con discapacidad visual podrían no percibir esta salida. Más adelante, exploraremos métodos alternativos para comunicar la información.",
    "H2_MODULE2": "Módulo 2: Entradas Interactivas y Retroalimentación Multisensorial",
    "H3_MODULE2_INPUTS": "Uso de Botones y Entradas Digitales",
    "P_MODULE2_INPUTS": "Exploraremos cómo los botones A y B, así como las entradas digitales, pueden ser utilizados para interactuar con nuestros programas. Para la accesibilidad, consideraremos cómo estas entradas pueden ser adaptadas o complementadas.",
    "H3_MODULE2_SOUND": "Integrando Sonido para Retroalimentación",
    "P_MODULE2_SOUND": "La retroalimentación auditiva es fundamental para la accesibilidad. Aprenderemos a usar el zumbador (o altavoz externo) para proporcionar sonidos que refuercen la información visual o la sustituyan completamente para usuarios con discapacidad visual. Por ejemplo, si un juego requiere que el usuario presione un botón, una combinación de una flecha visual en la pantalla LED y un sonido distintivo al presionar el botón puede mejorar significativamente la experiencia para todos.",
    "H2_MODULE3": "Módulo 3: Sensores y Adaptaciones para Diversidad Funcional",
    "H3_MODULE3_SENSORS": "Lectura de Sensores (Acelerómetro, Brújula, Temperatura)",
    "P_MODULE3_SENSORS": "La Micro:bit cuenta con varios sensores incorporados que nos permiten interactuar con el entorno. Aprenderemos a leer datos del acelerómetro (para detectar movimiento), la brújula (para la orientación) y el sensor de temperatura.",
    "H3_MODULE3_ADAPTATIONS": "Adaptaciones de Sensores para Accesibilidad",
    "P_MODULE3_ADAPTATIONS": "Analizaremos cómo los datos de los sensores pueden ser utilizados para crear interacciones alternativas. Por ejemplo, un programa que se activa al inclinar la Micro:bit podría ser más accesible para personas con movilidad reducida que un botón tradicional. Además, veremos cómo la información obtenida de los sensores puede ser traducida a salidas multisensoriales (visual, auditiva, táctil).",
    "H2_CONCLUSIONS": "Conclusiones y Próximos Pasos",
    "P_CONCLUSIONS": "Este curso ha cubierto las bases de la programación en MicroPython con un fuerte énfasis en el diseño accesible. Recuerda que la accesibilidad no es una característica adicional, sino un principio fundamental para crear tecnología inclusiva. ¡Anímate a explorar más proyectos y a seguir aprendiendo cómo hacer la tecnología accesible para todos!"
  },
  "ACCESSIBILITY_EVALUATOR_PAGE": {
    "H2": "Comprobador de Accesibilidad del código",
    "P": "Introduce tu código de MicroPython para la Micro:bit en el área de texto. El editor te ayudará a comprobar su accesibilidad.",
    "BTN": "Comprobar la Accesibilidad",
    "TEXTAREA_PLACEHOLDER": "Escribe tu código MicroPython aquí...",
    "EVALUATION_RESULTS_H3": "Resultado de la evaluación",
    "SCORE": "Puntuación",
    "IMPROVEMENT": "Mejora",
    "REDUNDANCY_DETECTED": "Redundancia de entrada detectada",
    "YES": "Sí",
    "NO": "No",
    "NO_BUTTONS_USED": "No se utilizan los botones",
    "ERRORS": "Errores",
    "WARNINGS": "Advertencias",
    "CODE_PREVIEW_H3": "Sugerencia de corrección del Código"
  },
  "VALIDATOR": {
    "AUDIO_FEEDBACK": {
      "SUCCESS_MESSAGE": "Multimodalidad: Se ha detectado la importación de audio.",
      "SUCCESS_MESSAGE_2": "Multimodalidad: Se ha detectado la salida de audio.",
      "ERROR_MESSAGE": "Falta salida de sonido.",
      "ERROR_SUGGESTION": "Añade 'speech.say('[string]')', 'music.play(music.[song])' o 'music.([number])' para que los usuarios con discapacidad visual reciban información.",
      "ERROR_SUGGESTION_2": "Importa 'speech' o 'music' para que los usuarios con discapacidad visual reciban información.",
      "MISSING_AUDIO_OUTPUT_WITH_DISPLAY_SHOW": "Solo usas display.show() sin salida de audio.",
      "SUGGEST_AUDIO_OUTPUT_WITH_DISPLAY_SHOW": "Añade 'import speech' o 'import music' y utiliza 'speech.say()' o 'music.play()' para proporcionar retroalimentación auditiva a los usuarios con discapacidad visual."
    },
    "BLOCKING_LOOPS": {
      "WARNING_MESSAGE": "Se ha detectado un bucle de bloqueo.",
      "WARNING_SUGGESTION": "Usas sleep() muy largos. Esto impide que la Micro:bit reaccione rápidamente a los botones o a las órdenes de voz."
    },
    "INPUT_REDUNDANCY": {
      "SUCCESS_MESSAGE": "Entrada accesible: Utilizas sensores táctiles o de movimiento.",
      "ERROR_MESSAGE": "Solo usas botones físicos.",
      "ERROR_SUGGESTION": "Añade 'pin_logo.is_touched()' para facilitar el uso a personas con dificultad motriz."
    },
    "COMPLEX_PRESSES": {
      "WARNING_MESSAGE": "Se ha detectado una pulsación compleja.",
      "WARNING_SUGGESTION": "Evita solicitar la pulsación simultánea de dos botones o un botón y el logotipo, ya que dificulta la interacción para usuarios con ciertas discapacidades motrices.",
      "SUCCESS_MESSAGE": "Pulsaciones simples: No se han detectado pulsaciones complejas."
    },
    "CODE_SEMANTICS": {
      "SUCCESS_MESSAGE": "Semántica: Las variables tienen nombres descriptivos.",
      "WARNING_MESSAGE": "Nombres de variables genéricos.",
      "WARNING_SUGGESTION": "Usa nombres como 'estado_alarma' en lugar de 'a' para facilitar la lectura con lectores de pantalla."
    }
  },
  "MANUAL_CHECK_MODAL_TITLE": "Verificación Manual de Accesibilidad",
  "MANUAL_CHECK_MODAL_QUESTION_1": "Los textos o iconos en pantalla LED son claros y legibles",
  "MANUAL_CHECK_MODAL_QUESTION_2": "No depende únicamente de luces o colores para transmitir información",
  "MANUAL_CHECK_MODAL_QUESTION_3": "El brillo de la pantalla LED es adecuado",
  "MANUAL_CHECK_MODAL_QUESTION_4": "Se ofrecen alternativas al uso exclusivo de la pantalla",
  "MANUAL_CHECK_MODAL_QUESTION_5": "Las señales sonoras tienen alternativa visual",
  "MANUAL_CHECK_MODAL_QUESTION_6": "El volumen es suficiente",
  "MANUAL_CHECK_MODAL_QUESTION_7": "No requiere movimientos finos",
  "MANUAL_CHECK_MODAL_QUESTION_8": "Los botones A y B no son la única forma de interacción",
  "MANUAL_CHECK_MODAL_QUESTION_9": "Se puede usar con adaptaciones (pulsadores externos, pinzas cocodrilo, etc.)",
  "MANUAL_CHECK_MODAL_QUESTION_10": "No requiere agitar con fuerza si usa sensor de movimiento",
  "MANUAL_CHECK_MODAL_QUESTION_11": "Las instrucciones son claras y simples",
  "MANUAL_CHECK_MODAL_QUESTION_12": "El proyecto tiene retroalimentación inmediata",
  "MANUAL_CHECK_MODAL_QUESTION_13": "No sobrecarga con demasiadas señales simultáneas",
  "MANUAL_CHECK_MODAL_QUESTION_14": "El comportamiento del programa es predecible",
  "MANUAL_CHECK_MODAL_QUESTION_15": "Puede usarse sentado/a o con soporte fijo",
  "MANUAL_CHECK_MODAL_QUESTION_16": "La documentación explica cómo adaptarlo",
  "MANUAL_CHECK_MODAL_QUESTION_17": "Ha sido probado por usuarios con diferentes necesidades",
  "MANUAL_CHECK_MODAL_OPTION_YES": "Sí",
  "MANUAL_CHECK_MODAL_OPTION_PARTIAL": "Parcial",
  "MANUAL_CHECK_MODAL_OPTION_NO": "No",
  "MANUAL_CHECK_MODAL_SUBMIT": "Enviar",
  "MANUAL_CHECK_MODAL_CANCEL": "Cancelar",
  "RESULTS_MODAL_TITLE": "Resultados de la Evaluación de Accesibilidad",
  "RESULTS_MODAL_SCORE": "Puntuación Total",
  "RESULTS_MODAL_FEEDBACK_0_17": "Necesita mejoras importantes",
  "RESULTS_MODAL_FEEDBACK_18_27": "Accesibilidad media (mejorable)",
  "RESULTS_MODAL_FEEDBACK_28_36": "Proyecto altamente accesible",
  "RESULTS_MODAL_ACCEPT": "Aceptar",
  "MANUAL_CHECK_MODAL_HEADER_QUESTION": "Pregunta"
}